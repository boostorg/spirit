#include "config.hpp"
#include "types_def.hpp"
#include <iostream>

namespace client {namespace parser {

BOOST_SPIRIT_INSTANTIATE(type_type, iterator_type, context_type);

BOOST_SPIRIT_INSTANTIATE(class_type_type, iterator_type, context_type);
#define PARSE_RULE_BODY
#if defined(PARSE_RULE_BODY)
  #pragma message "yesdef(PARSE_RULE_BODY)"
  //This causes the parse_rule generated by
  //BOOST_SPIRIT_DEFINE for type
  //to *not* be used.
  #include <boost/fusion/iterator/deref.hpp>
#else
  #pragma message "notdef(PARSE_RULE_BODY)"
  //This causes  the parse_rule generated by
  //BOOST_SPIRIT_DEFINE for type
  //to be used.
#endif
//#define SEHE_TYPES_DEF_HPP_PASTE
//#define EXPLICIT_SPECIALIZATION_FROM_LINKER_ERROR_MSG
#if defined(SEHE_TYPES_DEF_HPP_PASTE)
#pragma message "yesdef(SEHE_TYPES_DEF_HPP_PASTE)"
//Source:
//  The following code was copy&pasted&reformatted from lines 38-53 of:
//   https://github.com/sehe/linker_error_example/blob/explicit_instantiation/types_def.hpp
//  on about 2016-11-15.
//  with minor modifications:
//    * reformatting
//    * Added body with:
//      * printing first..last.
//=======================
namespace {
      template <typename Seq, size_t N>
    using field_at = 
      boost::fusion::basic_iterator
      < boost::fusion::struct_iterator_tag
      , boost::fusion::random_access_traversal_tag
      , Seq
      , N
      >;
      template <typename Seq, size_t N, size_t M>
    using fields = 
      boost::fusion::iterator_range<field_at<Seq, N>, field_at<Seq, M> >;
    using AttributeActual = 
      fields<client::ast::VariableDec, 1, 2>;
    using Context = 
      x3::context
      < x3::skipper_tag
      , x3::char_class<boost::spirit::char_encoding::ascii, x3::space_tag> const
      , x3::unused_type
      >;
}
template
  #ifdef PARSE_RULE_BODY
    <> 
  #endif
    bool parse_rule
    < std::string::const_iterator
    , Context
    , AttributeActual
    >(
    decltype(type) rule,
    std::string::const_iterator &first, 
    std::string::const_iterator const &last,
    Context const &context,
    AttributeActual &attr_actual_v)
    #ifndef PARSE_RULE_BODY
      ;
    #else
      {
        std::cout<<"***in function="<<__func__<<"\n";
        std::string::const_iterator beg=first;
        std::cout<<":input=\n{";
        for(; beg!=last; ++beg) std::cout<<*beg;
        std::cout<<"}\n";
        using rule_t=decltype(type);
        using attr_rule_t=rule_t::attribute_type;
        attr_rule_t attr_rule_v=boost::fusion::deref(attr_actual_v.first);
          //attr type required by parse_rule generated by:
          //  BOOST_SPIRIT_INSTANTIATE(rule_t, iterator_type, context_type)
          ;
      #define EMULATE_SPIRIT_DEFINE
      #ifdef EMULATE_SPIRIT_DEFINE
        #pragma message "yesdef(EMULATE_SPIRIT_DEFINE)"
        //this code is copy&pasted from BOOST_SPIRIT_DEFINE_
        //macro defined in rule.hpp.
        using boost::spirit::x3::unused;
        static auto const def_ = (rule = type_def);
        bool result=def_.parse(first, last, context, unused, attr_actual_v);
      #else
        #pragma message "notdef(EMULATE_SPIRIT_DEFINE)"
        bool result=parse_rule(rule,first,last,context,required_v)
          //This should call the parse_rule generated by:
          //  BOOST_SPIRIT_INSTANTIATE(type_type, iterator_type, context_type)
          ;
      #endif//EMULATE_SPIRIT_DEFINE
        std::cout<<":result="<<result<<"\n";
        return result;
      }
    #endif

#elif defined(EXPLICIT_SPECIALIZATION_FROM_LINKER_ERROR_MSG)
#pragma message "yesdef(EXPLICIT_SPECIALIZATION_FROM_LINKER_ERROR_MSG)"
template
  #ifdef PARSE_RULE_BODY
    <> 
  #endif
  //The following simply copied&pasted from an earlier linker error
  //message, and then reformatted to clarify what
  //was being specialized.
  bool
  parse_rule
  < __gnu_cxx::__normal_iterator
    < char const*
    , std::__cxx11::basic_string
      < char
      , std::char_traits<char>
      , std::allocator<char> 
      > 
    >
  , boost::spirit::x3::context
    < boost::spirit::x3::skipper_tag
    , boost::spirit::x3::char_class
      < boost::spirit::char_encoding::ascii
      , boost::spirit::x3::space_tag
      > const
    , boost::spirit::x3::unused_type
    >
  , boost::fusion::iterator_range
    < boost::fusion::basic_iterator
      < boost::fusion::struct_iterator_tag
      , boost::fusion::random_access_traversal_tag
      , client::ast::VariableDec
      , 1
      >
    , boost::fusion::basic_iterator
      < boost::fusion::struct_iterator_tag
      , boost::fusion::random_access_traversal_tag
      , client::ast::VariableDec
      , 2
      > 
    >
  >
  ( boost::spirit::x3::rule//==decltype(type) where types from types_def.hpp:16
    < client::parser::type_class//types.hpp:15
    , boost::spirit::x3::variant
      < client::ast::nil
      , boost::spirit::x3::forward_ast
        < client::ast::LambdaType
        >
      , boost::spirit::x3::forward_ast
        < client::ast::ClassType
        > 
      >
    , false
    >
  , __gnu_cxx::__normal_iterator//==std::string::const_iterator
    < char const*
    , std::__cxx11::basic_string
      < char
      , std::char_traits<char>
      , std::allocator<char> 
      > 
    >& first
  , __gnu_cxx::__normal_iterator//==std::string::const_iterator
    < char const*
    , std::__cxx11::basic_string
      < char
      , std::char_traits<char>
      , std::allocator<char> 
      > 
    > const& last
  , boost::spirit::x3::context//=?Context from #if defined(SEHE_TYPES_DEF_HPP_PASTE)
    < boost::spirit::x3::skipper_tag
    , boost::spirit::x3::char_class
      < boost::spirit::char_encoding::ascii
      , boost::spirit::x3::space_tag
      > const
    , boost::spirit::x3::unused_type
    > const& context
  , boost::fusion::iterator_range//=?Attributes from #if defined(SEHE_TYPES_DEF_HPP_PASTE)
    < boost::fusion::basic_iterator
      < boost::fusion::struct_iterator_tag
      , boost::fusion::random_access_traversal_tag
      , client::ast::VariableDec
      , 1
      >
    , boost::fusion::basic_iterator
      < boost::fusion::struct_iterator_tag
      , boost::fusion::random_access_traversal_tag
      , client::ast::VariableDec
      , 2
      > 
    >& attr
  )
#ifndef PARSE_RULE_BODY
  ;
#else
  {
    std::cout<<"***in function="<<__func__<<"\n";
    std::string::const_iterator beg=first;
    std::cout<<":input=\n{";
    for(; beg!=last; ++beg) std::cout<<*beg;
    std::cout<<"}\n";
    return false;
  }
#endif//PARSE_RULE_BODY
#else
#pragma message "notdef(SEHE_TYPES_DEF_HPP_PASTE)"
#pragma message "notdef(EXPLICIT_SPECIALIZATION_FROM_LINKER_ERROR_MSG)"
#endif//(SEHE_TYPES_DEF_HPP_PASTE)
}}


