<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Mini XML - ASTs!</title>
<link rel="stylesheet" href="../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="../../../index.html" title="Spirit 2.1">
<link rel="up" href="../tutorials.html" title="Tutorials">
<link rel="previous" href="employee___parsing_into_structs.html" title="Employee
        - Parsing into structs">
<link rel="next" href="mini_xml___error_handling.html" title="Mini
        XML - Error Handling">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="employee___parsing_into_structs.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorials.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="mini_xml___error_handling.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="spirit.qi.tutorials.mini_xml___asts_"></a><a href="mini_xml___asts_.html" title="Mini XML - ASTs!">Mini XML - ASTs!</a>
</h4></div></div>
<div></div>
</div>
<p>
          Stop and think about it... We've come very close to generating an AST in
          our last example. We parsed a single structure and generated an in-memory
          representation of it in the form of a struct: the <tt class="computeroutput"><span class="keyword">struct</span>
          <span class="identifier">employee</span></tt>. If we changed the implementation
          to parse one or more employees, the result would be a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">employee</span><span class="special">&gt;</span></tt>. We can go on and add more hierarchy:
          teams, departments, corporations. Then we'll have an AST representation
          of it all.
        </p>
<p>
          In this example (actually two examples), we'll now explore parsers how
          to create ASTs. We will parse a minimalistic XML like language and compile
          the results into our data structures in the form of a tree.
        </p>
<p>
          Along the way, we'll see new features:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            Inherited attributes
          </li>
<li>
            Variant attributes
          </li>
<li>
            Local Variables
          </li>
<li>
            Not Predicate
          </li>
<li>
            Lazy Lit
          </li>
</ul></div>
<p>
          The full cpp files for these examples can be found here: <a href="../../../../../example/qi/mini_xml1.cpp" target="_top">../../example/qi/mini_xml1.cpp</a>
          and here: <a href="../../../../../example/qi/mini_xml2.cpp" target="_top">../../example/qi/mini_xml2.cpp</a>
        </p>
<p>
          There are a couple of sample toy-xml files in: <a href="../../../../../example/qi/mini_xml_samples" target="_top">../../example/qi/mini_xml_samples</a>
          for testing purposes. "4.toyxml" has an error in it.
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.first_cut"></a><h5>
<a name="id437324"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.first_cut">First Cut</a>
        </h5>
<p>
          Without further delay, here's the first version of the XML grammar:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mini_xml_grammar</span> <span class="special">:</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">mini_xml_grammar</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">mini_xml_grammar</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">xml</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">lit</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">lexeme</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">char_</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">string</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">labels</span><span class="special">;</span>

        <span class="keyword">using</span> <span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">at_c</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">;</span>

        <span class="identifier">text</span> <span class="special">=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)</span>        <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]];</span>
        <span class="identifier">node</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">)</span>                 <span class="special">[</span><span class="identifier">_val</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">];</span>

        <span class="identifier">start_tag</span> <span class="special">=</span>
                <span class="char">'&lt;'</span>
            <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">lit</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)</span>       <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]]</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">end_tag</span> <span class="special">=</span>
                <span class="string">"&lt;/"</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">string</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">xml</span> <span class="special">=</span>
                <span class="identifier">start_tag</span>                   <span class="special">[</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
            <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>                       <span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)]</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">))</span>
        <span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Going bottom up, let's examine the <tt class="computeroutput"><span class="identifier">text</span></tt>
          rule:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
</pre>
<p>
          and its definition:
        </p>
<pre class="programlisting"><span class="identifier">text</span> <span class="special">=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)</span>        <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]];</span>
</pre>
<p>
          The semantic action collects the chars and appends them (via +=) to the
          <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt> attribute of the rule (represented
          by the placeholder <tt class="computeroutput"><span class="identifier">_val</span></tt>).
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.alternates"></a><h5>
<a name="id438925"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.alternates">Alternates</a>
        </h5>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
</pre>
<p>
          and its definition:
        </p>
<pre class="programlisting"><span class="identifier">node</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">)</span>                 <span class="special">[</span><span class="identifier">_val</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">];</span>
</pre>
<p>
          We'll see what a <tt class="computeroutput"><span class="identifier">mini_xml_node</span></tt>
          structure is later. Looking at the rule definition, we see some alternation
          going on here. An xml <tt class="computeroutput"><span class="identifier">node</span></tt>
          is either an <tt class="computeroutput"><span class="identifier">xml</span></tt> OR <tt class="computeroutput"><span class="identifier">text</span></tt>. Hmmm... hold on to that thought...
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
</pre>
<p>
          Again, with an attribute of <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt>.
          Then, it's definition:
        </p>
<pre class="programlisting"><span class="identifier">start_tag</span> <span class="special">=</span>
        <span class="char">'&lt;'</span>
    <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)</span>       <span class="special">[</span><span class="identifier">_val</span> <span class="special">+=</span> <span class="identifier">_1</span><span class="special">]]</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<a name="spirit.qi.tutorials.mini_xml___asts_.not_predicate"></a><h5>
<a name="id439386"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.not_predicate">Not
          Predicate</a>
        </h5>
<p>
          <tt class="computeroutput"><span class="identifier">start_tag</span></tt> is similar to
          the <tt class="computeroutput"><span class="identifier">text</span></tt> rule apart from
          the added <tt class="computeroutput"><span class="char">'&lt;'</span></tt> and <tt class="computeroutput"><span class="char">'&gt;'</span></tt>. But wait, to make sure that the <tt class="computeroutput"><span class="identifier">start_tag</span></tt> does not parse <tt class="computeroutput"><span class="identifier">end_tag</span></tt>s too, we add: <tt class="computeroutput"><span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span></tt>. This
          is a "Not Predicate":
        </p>
<pre class="programlisting"><span class="special">!</span><span class="identifier">p</span>
</pre>
<p>
          It will try the parser, <tt class="computeroutput"><span class="identifier">p</span></tt>.
          If it is successful, fail, otherwise, pass. In other words, it negates
          the result of <tt class="computeroutput"><span class="identifier">p</span></tt>. Like the
          <tt class="computeroutput"><span class="identifier">eps</span></tt>, it does not consume
          any input though. It will always rewind the iterator position to where
          it was upon entry. So, the expression:
        </p>
<pre class="programlisting"><span class="special">!</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
</pre>
<p>
          basically says: we should not have a <tt class="computeroutput"><span class="char">'/'</span></tt>
          at this point.
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.inherited_attribute"></a><h5>
<a name="id439627"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.inherited_attribute">Inherited
          Attribute</a>
        </h5>
<p>
          The <tt class="computeroutput"><span class="identifier">end_tag</span></tt>:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
</pre>
<p>
          Ohh! Now we see an inherited attribute there: <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt>.
          The <tt class="computeroutput"><span class="identifier">end_tag</span></tt> does not have
          a synthesized attribute. Let's see its definition:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span> <span class="special">=</span>
        <span class="string">"&lt;/"</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">_r1</span></tt> is yet another <a href="../../../../../phoenix/doc/html/index.html" target="_top">Phoenix</a> placeholder for
          the first inherited attribute (we have only one, use <tt class="computeroutput"><span class="identifier">_r2</span></tt>,
          <tt class="computeroutput"><span class="identifier">_r3</span></tt>, etc. if you have more).
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.a_lazy_lit"></a><h5>
<a name="id439906"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.a_lazy_lit">A Lazy
          Lit</a>
        </h5>
<p>
          Check out how we used <tt class="computeroutput"><span class="identifier">lit</span></tt>
          here, this time, not with a literal string, but with the value of the first
          inherited attribute, which is specified as <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt>
          in our rule declaration.
        </p>
<p>
          Finally, our <tt class="computeroutput"><span class="identifier">xml</span></tt> rule:
        </p>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
</pre>
<p>
          <tt class="computeroutput"><span class="identifier">mini_xml</span></tt> is our attribute
          here. We'll see later what it is. Let's see its definition:
        </p>
<pre class="programlisting"><span class="identifier">xml</span> <span class="special">=</span>
        <span class="identifier">start_tag</span>                   <span class="special">[</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
    <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>                       <span class="special">[</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">),</span> <span class="identifier">_1</span><span class="special">)]</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">))</span>
<span class="special">;</span>
</pre>
<p>
          Those who know <a href="../../../../../../../libs/fusion/doc/html/index.html" target="_top">Boost.Fusion</a>
          now will notice <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;</span></tt> and
          <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;</span></tt>. This
          gives us a hint that <tt class="computeroutput"><span class="identifier">mini_xml</span></tt>
          is a sort of a tuple - a fusion sequence. <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span></tt> here is a lazy version of the tuple
          accessors, provided by <a href="../../../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>.
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.how_it_all_works"></a><h5>
<a name="id440386"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.how_it_all_works">How
          it all works</a>
        </h5>
<p>
          So, what's happening?
        </p>
<div class="orderedlist"><ol type="1">
<li>
            Upon parsing <tt class="computeroutput"><span class="identifier">start_tag</span></tt>,
            the parsed start-tag string is placed in <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>.
          </li>
<li>
            Then we parse zero or more <tt class="computeroutput"><span class="identifier">node</span></tt>s.
            At each step, we <tt class="computeroutput"><span class="identifier">push_back</span></tt>
            the result into <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>.
          </li>
<li>
            Finally, we parse the <tt class="computeroutput"><span class="identifier">end_tag</span></tt>
            giving it an inherited attribute: <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>.
            This is the string we obtained from the <tt class="computeroutput"><span class="identifier">start_tag</span></tt>.
            Investigate <tt class="computeroutput"><span class="identifier">end_tag</span></tt> above.
            It will fail to parse if it gets something different from what we got
            from the <tt class="computeroutput"><span class="identifier">start_tag</span></tt>. This
            ensures that our tags are balanced.
          </li>
</ol></div>
<p>
          To give the last item some more light, what happens is this:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">))</span>
</pre>
<p>
          calls:
        </p>
<pre class="programlisting"><span class="identifier">end_tag</span> <span class="special">=</span>
        <span class="string">"&lt;/"</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">lit</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
<span class="special">;</span>
</pre>
<p>
          passing in <tt class="computeroutput"><span class="identifier">at_c</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">_val</span><span class="special">)</span></tt>, the string from start tag. This is referred
          to in the <tt class="computeroutput"><span class="identifier">end_tag</span></tt> body
          as <tt class="computeroutput"><span class="identifier">_r1</span></tt>.
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.the_structures"></a><h5>
<a name="id440829"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.the_structures">The
          Structures</a>
        </h5>
<p>
          Let's see our structures. It will definitely be hierarchical: xml is hierarchical.
          It will also be recursive: xml is recursive.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">mini_xml</span><span class="special">;</span>

<span class="keyword">typedef</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">mini_xml</span><span class="special">&gt;</span>
      <span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span>
    <span class="special">&gt;</span>
<span class="identifier">mini_xml_node</span><span class="special">;</span>

<span class="keyword">struct</span> <span class="identifier">mini_xml</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">;</span>                           <span class="comment">// tag name
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">mini_xml_node</span><span class="special">&gt;</span> <span class="identifier">children</span><span class="special">;</span>        <span class="comment">// children
</span><span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.of_alternates_and_variants"></a><h5>
<a name="id441097"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.of_alternates_and_variants">Of
          Alternates and Variants</a>
        </h5>
<p>
          So that's how a <tt class="computeroutput"><span class="identifier">mini_xml_node</span></tt>
          looks like. We had a hint that it is either a <tt class="computeroutput"><span class="identifier">string</span></tt>
          or a <tt class="computeroutput"><span class="identifier">mini_xml</span></tt>. For this,
          we use <a href="http://www.boost.org/doc/html/variant.html" target="_top">Boost.Variant</a>.
          <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></tt> wraps <tt class="computeroutput"><span class="identifier">mini_xml</span></tt>, making it a recursive data
          structure.
        </p>
<p>
          Yep, you got that right: the attribute of an alternate:
        </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">|</span> <span class="identifier">b</span>
</pre>
<p>
          is a
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;</span>
</pre>
<p>
          where <tt class="computeroutput"><span class="identifier">A</span></tt> is the attribute
          of <tt class="computeroutput"><span class="identifier">a</span></tt> and <tt class="computeroutput"><span class="identifier">B</span></tt> is the attribute of <tt class="computeroutput"><span class="identifier">b</span></tt>.
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.adapting_structs_again"></a><h5>
<a name="id441340"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.adapting_structs_again">Adapting
          structs again</a>
        </h5>
<p>
          <tt class="computeroutput"><span class="identifier">mini_xml</span></tt> is no brainier.
          It is a plain ol' struct. But as we've seen in our employee example, we
          can adapt that to be a <a href="../../../../../../../libs/fusion/doc/html/index.html" target="_top">Boost.Fusion</a>
          sequence:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="identifier">BOOST_FUSION_ADAPT_STRUCT</span><span class="special">(</span>
    <span class="identifier">client</span><span class="special">::</span><span class="identifier">mini_xml</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">name</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">client</span><span class="special">::</span><span class="identifier">mini_xml_node</span><span class="special">&gt;,</span> <span class="identifier">children</span><span class="special">)</span>
<span class="special">)</span>
</pre>
<p>
          </p>
<p>
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.one_more_take"></a><h5>
<a name="id441537"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.one_more_take">One
          More Take</a>
        </h5>
<p>
          Here's another version. The AST structure remains the same, but this time,
          you'll see that we make use of auto-rules making the grammar semantic-action-less.
          Here it is:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">mini_xml_grammar</span>
  <span class="special">:</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">mini_xml_grammar</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">mini_xml_grammar</span><span class="special">::</span><span class="identifier">base_type</span><span class="special">(</span><span class="identifier">xml</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">lit</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">lexeme</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">char_</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">string</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">labels</span><span class="special">;</span>

        <span class="identifier">text</span> <span class="special">%=</span> <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&lt;'</span><span class="special">)];</span>
        <span class="identifier">node</span> <span class="special">%=</span> <span class="identifier">xml</span> <span class="special">|</span> <span class="identifier">text</span><span class="special">;</span>

        <span class="identifier">start_tag</span> <span class="special">%=</span>
                <span class="char">'&lt;'</span>
            <span class="special">&gt;&gt;</span>  <span class="special">!</span><span class="identifier">lit</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">lexeme</span><span class="special">[+(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'&gt;'</span><span class="special">)]</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">end_tag</span> <span class="special">=</span>
                <span class="string">"&lt;/"</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">string</span><span class="special">(</span><span class="identifier">_r1</span><span class="special">)</span>
            <span class="special">&gt;&gt;</span>  <span class="char">'&gt;'</span>
        <span class="special">;</span>

        <span class="identifier">xml</span> <span class="special">%=</span>
                <span class="identifier">start_tag</span><span class="special">[</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
            <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>
            <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">_a</span><span class="special">)</span>
        <span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">qi</span><span class="special">::</span><span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml_node</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">node</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">text</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">start_tag</span><span class="special">;</span>
    <span class="identifier">qi</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="keyword">void</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">),</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">end_tag</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          This one shouldn't be any more difficult to understand after going through
          the first xml parser example. The rules are almost the same, except that,
          we got rid of semantic actions and used auto-rules (see the employee example
          if you missed that). There are a couple of new stuff, though. It's all
          in the <tt class="computeroutput"><span class="identifier">xml</span></tt> rule:
        </p>
<a name="spirit.qi.tutorials.mini_xml___asts_.local_variables"></a><h5>
<a name="id442782"></a>
          <a href="mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.local_variables">Local
          Variables</a>
        </h5>
<pre class="programlisting"><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">Iterator</span><span class="special">,</span> <span class="identifier">mini_xml</span><span class="special">(),</span> <span class="identifier">locals</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,</span> <span class="identifier">space_type</span><span class="special">&gt;</span> <span class="identifier">xml</span><span class="special">;</span>
</pre>
<p>
          Wow, we have four template parameters now. What's that <tt class="computeroutput"><span class="identifier">locals</span></tt>
          guy doing there? Well, it declares that the rule <tt class="computeroutput"><span class="identifier">xml</span></tt>
          will have one local variable: a <tt class="computeroutput"><span class="identifier">string</span></tt>.
          Let's see how this is used in action:
        </p>
<pre class="programlisting"><span class="identifier">xml</span> <span class="special">%=</span>
        <span class="identifier">start_tag</span><span class="special">[</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">_1</span><span class="special">]</span>
    <span class="special">&gt;&gt;</span>  <span class="special">*</span><span class="identifier">node</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">end_tag</span><span class="special">(</span><span class="identifier">_a</span><span class="special">)</span>
<span class="special">;</span>
</pre>
<div class="orderedlist"><ol type="1">
<li>
            Upon parsing <tt class="computeroutput"><span class="identifier">start_tag</span></tt>,
            the parsed start-tag string is placed in the local variable specified
            by (yet another) <a href="../../../../../phoenix/doc/html/index.html" target="_top">Phoenix</a>
            placeholder: <tt class="computeroutput"><span class="identifier">_a</span></tt>. We have
            only one local variable. If we had more, these are designated by <tt class="computeroutput"><span class="identifier">_b</span></tt>..<tt class="computeroutput"><span class="identifier">_z</span></tt>.
          </li>
<li>
            Then we parse zero or more <tt class="computeroutput"><span class="identifier">node</span></tt>s.
          </li>
<li>
            Finally, we parse the <tt class="computeroutput"><span class="identifier">end_tag</span></tt>
            giving it an inherited attribute: <tt class="computeroutput"><span class="identifier">_a</span></tt>,
            our local variable.
          </li>
</ol></div>
<p>
          There are no actions involved in stuffing data into our <tt class="computeroutput"><span class="identifier">xml</span></tt>
          attribute. It's all taken care of thanks to the auto-rule.
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2009 Joel
      de Guzman, Hartmut Kaiser<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="employee___parsing_into_structs.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorials.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="mini_xml___error_handling.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
