<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Lexer
        Semantic Actions</title>
<link rel="stylesheet" href="../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="../../../index.html" title="Spirit 2.1">
<link rel="up" href="../abstracts.html" title=" Abstracts">
<link rel="previous" href="lexer_tokenizing.html" title=" Tokenizing
        Input Data">
<link rel="next" href="lexer_static_model.html" title=" The Static
        Lexer Model">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="lexer_tokenizing.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../abstracts.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="lexer_static_model.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="spirit.lex.abstracts.lexer_semantic_actions"></a><a href="lexer_semantic_actions.html" title=" Lexer
        Semantic Actions"> Lexer
        Semantic Actions</a>
</h4></div></div>
<div></div>
</div>
<p>
          The main task of a lexer normally is to recognize tokens in the input.
          Traditionally this has been complemented with the possibility to execute
          arbitrary code whenever a certain token has been detected. <span class="emphasis"><em>Spirit.Lex</em></span>
          has been designed to support this mode of operation as well. We borrow
          from the concept of semantic actions for parsers (<span class="emphasis"><em>Spirit.Qi</em></span>)
          and generators (<span class="emphasis"><em>Spirit.Karma</em></span>). Lexer semantic actions
          may be attached to any token definition. These are C++ functions or function
          objects that are called whenever a token definition successfully recognizes
          a portion of the input. Say you have a token definition <tt class="computeroutput"><span class="identifier">D</span></tt>,
          and a C++ function <tt class="computeroutput"><span class="identifier">f</span></tt>, you
          can make the lexer call <tt class="computeroutput"><span class="identifier">f</span></tt>
          whenever it matches an input by attaching <tt class="computeroutput"><span class="identifier">f</span></tt>:
        </p>
<pre class="programlisting"><span class="identifier">D</span><span class="special">[</span><span class="identifier">f</span><span class="special">]</span>
</pre>
<p>
          The expression above links <tt class="computeroutput"><span class="identifier">f</span></tt>
          to the token definition, <tt class="computeroutput"><span class="identifier">D</span></tt>.
          The required prototype of <tt class="computeroutput"><span class="identifier">f</span></tt>
          is:
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span> <span class="special">(</span><span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">pass_flag</span><span class="special">&amp;</span> <span class="identifier">matched</span><span class="special">,</span> <span class="identifier">Idtype</span><span class="special">&amp;</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">Context</span><span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b>where:</b></p>
<dl>
<dt><span class="term"><tt class="computeroutput"><span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">start</span></tt></span></dt>
<dd><p>
              This is a the iterator pointing to the begin of the matched range in
              the underlying input sequence. The type of the iterator is the same
              as specified while defining the type of the <tt class="computeroutput"><span class="identifier">lexertl_lexer</span><span class="special">&lt;...&gt;</span></tt> (its first template parameter).
              The semantic action is allowed to change the value of this iterator
              influencing, the matched input sequence.
            </p></dd>
<dt><span class="term"><tt class="computeroutput"><span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">end</span></tt></span></dt>
<dd><p>
              This is a the iterator pointing to the end of the matched range in
              the underlying input sequence. The type of the iterator is the same
              as specified while defining the type of the <tt class="computeroutput"><span class="identifier">lexertl_lexer</span><span class="special">&lt;...&gt;</span></tt> (its first template parameter).
              The semantic action is allowed to change the value of this iterator
              influencing, the matched input sequence.
            </p></dd>
<dt><span class="term"><tt class="computeroutput"><span class="identifier">pass_flag</span><span class="special">&amp;</span> <span class="identifier">matched</span></tt></span></dt>
<dd><p>
              This value is pre/initialized to <tt class="computeroutput"><span class="identifier">pass_normal</span></tt>.
              If the semantic action sets it to <tt class="computeroutput"><span class="identifier">pass_fail</span></tt>
              the behaves as if the token has not been matched in the first place.
              If the semantic action sets this to <tt class="computeroutput"><span class="identifier">pass_ignore</span></tt>
              the lexer ignores the current token and tries to match a next token
              from the input.
            </p></dd>
<dt><span class="term"><tt class="computeroutput"><span class="identifier">Idtype</span><span class="special">&amp;</span> <span class="identifier">id</span></tt></span></dt>
<dd><p>
              This is the token id of the type Idtype (most of the time this will
              be a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></tt>) for the matched token. The
              semantic action is allowed to change the value of this token id, influencing
              the if of the created token.
            </p></dd>
<dt><span class="term"><tt class="computeroutput"><span class="identifier">Context</span><span class="special">&amp;</span> <span class="identifier">ctx</span></tt></span></dt>
<dd><p>
              This is a reference to a lexer specific, unspecified type, providing
              the context for the current lexer state. It can be used to access different
              internal data items and is needed for lexer state control from inside
              a semantic action.
            </p></dd>
</dl>
</div>
<p>
          When using a C++ function as the semantic action the following prototypes
          are allowed as well:
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span> <span class="special">(</span><span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">pass_flag</span><span class="special">&amp;</span> <span class="identifier">matched</span><span class="special">,</span> <span class="identifier">Idtype</span><span class="special">&amp;</span> <span class="identifier">id</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">f</span> <span class="special">(</span><span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">pass_flag</span><span class="special">&amp;</span> <span class="identifier">matched</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">f</span> <span class="special">(</span><span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">Iterator</span><span class="special">&amp;</span> <span class="identifier">end</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">f</span> <span class="special">();</span>
</pre>
<a name="spirit.lex.abstracts.lexer_semantic_actions.the_context_of_a_lexer_semantic_action"></a><h5>
<a name="id610606"></a>
          <a href="lexer_semantic_actions.html#spirit.lex.abstracts.lexer_semantic_actions.the_context_of_a_lexer_semantic_action">The
          context of a lexer semantic action</a>
        </h5>
<p>
          The last parameter passed to any lexer semantic action is a reference to
          an unspecified type (see the <tt class="computeroutput"><span class="identifier">Context</span></tt>
          type in the table above). This type is unspecified because it depends on
          the token type returned by the lexer. It is implemented in the internals
          of the iterator type exposed by the lexer. Nevertheless, any context type
          is expected to expose a couple of functions allowing to influence the behavior
          of the lexer. The following table gives an overview and a short description
          of the available functionality.
        </p>
<div class="table">
<a name="id610650"></a><p class="title"><b>Table 9. Functions exposed by any context passed to a lexer
        semantic action</b></p>
<table class="table" summary="Functions exposed by any context passed to a lexer
        semantic action">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th><p>
                Name
              </p></th>
<th><p>
                Description
              </p></th>
</tr></thead>
<tbody>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">Iterator</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get_eoi</span><span class="special">()</span> <span class="keyword">const</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">get_eoi</span><span class="special">()</span></tt> may be used by to access the end
                iterator of the input stream the lexer has been initialized with
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="keyword">void</span> <span class="identifier">more</span><span class="special">()</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">more</span><span class="special">()</span></tt> tells the lexer that the next time
                it matches a rule, the corresponding token should be appended onto
                the current token value rather than replacing it.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">Iterator</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">less</span><span class="special">(</span><span class="identifier">Iterator</span>
                <span class="keyword">const</span><span class="special">&amp;</span>
                <span class="identifier">it</span><span class="special">,</span>
                <span class="keyword">int</span> <span class="identifier">n</span><span class="special">)</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">less</span><span class="special">()</span></tt> returns an iterator positioned
                to the nth input character beyond the current token start iterator
                (i.e. by passing the return value to the parameter <tt class="computeroutput"><span class="identifier">end</span></tt> it is possible to return all
                but the first n characters of the current token back to the input
                stream.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="keyword">bool</span> <span class="identifier">lookahead</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span>
                <span class="identifier">id</span><span class="special">)</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">lookahead</span><span class="special">()</span></tt> can be for instance used to implement
                lookahead for lexer engines not supporting constructs like flex'
                <tt class="computeroutput"><span class="identifier">a</span><span class="special">/</span><span class="identifier">b</span></tt> (match <tt class="computeroutput"><span class="identifier">a</span></tt>,
                but only when followed by <tt class="computeroutput"><span class="identifier">b</span></tt>).
                It invokes the lexer on the input following the current token without
                actually moving forward in the input stream. The function returns
                whether the lexer was able to match a token with the given token-id
                <tt class="computeroutput"><span class="identifier">id</span></tt>.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">get_state</span><span class="special">()</span> <span class="keyword">const</span></tt>
                and <tt class="computeroutput"><span class="keyword">void</span> <span class="identifier">set_state</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span>
                <span class="identifier">state</span><span class="special">)</span></tt>
              </p></td>
<td><p>
                The functions <tt class="computeroutput"><span class="identifier">get_state</span><span class="special">()</span></tt> and <tt class="computeroutput"><span class="identifier">set_state</span><span class="special">()</span></tt> may be used to introspect and change
                the current lexer state.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">token_value_type</span> <span class="identifier">get_value</span><span class="special">()</span>
                <span class="keyword">const</span></tt> and <tt class="computeroutput"><span class="keyword">void</span>
                <span class="identifier">set_value</span><span class="special">(</span><span class="identifier">Value</span> <span class="keyword">const</span><span class="special">&amp;)</span></tt>
              </p></td>
<td><p>
                The functions <tt class="computeroutput"><span class="identifier">get_value</span><span class="special">()</span></tt> and <tt class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></tt> may be used to introspect and change
                the current token value.
              </p></td>
</tr>
</tbody>
</table>
</div>
<a name="spirit.lex.abstracts.lexer_semantic_actions.lexer_semantic_actions_using_phoenix"></a><h5>
<a name="id611375"></a>
          <a href="lexer_semantic_actions.html#spirit.lex.abstracts.lexer_semantic_actions.lexer_semantic_actions_using_phoenix">Lexer
          Semantic Actions Using Phoenix</a>
        </h5>
<p>
          Even if it is possible to write your own function object implementations
          (i.e. using Boost.Lambda or Boost.Bind), the preferred way of defining
          lexer semantic actions is to use <a href="../../../../../phoenix/doc/html/index.html" target="_top">Boost.Phoenix</a>.
          In this case you can access the parameters described above by using the
          predefined <a href="http://spirit.sourceforge.net" target="_top">Spirit</a> placeholders:
        </p>
<div class="table">
<a name="id611417"></a><p class="title"><b>Table 10. Predefined Phoenix placeholders for lexer semantic
        actions</b></p>
<table class="table" summary="Predefined Phoenix placeholders for lexer semantic
        actions">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th><p>
                Placeholder
              </p></th>
<th><p>
                Description
              </p></th>
</tr></thead>
<tbody>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_start</span></tt>
              </p></td>
<td><p>
                Refers to the iterator pointing to the begin of the matched input
                sequence. Any modifications to this iterator value will be reflected
                in the generated token.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_end</span></tt>
              </p></td>
<td><p>
                Refers to the iterator pointing past the end of the matched input
                sequence. Any modifications to this iterator value will be reflected
                in the generated token.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_pass</span></tt>
              </p></td>
<td><p>
                References the value signaling the outcome of the semantic action.
                This is pre-initialized to <tt class="computeroutput"><span class="identifier">lex</span><span class="special">::</span><span class="identifier">pass_flags</span><span class="special">::</span><span class="identifier">pass_normal</span></tt>.
                If this is set to <tt class="computeroutput"><span class="identifier">lex</span><span class="special">::</span><span class="identifier">pass_flags</span><span class="special">::</span><span class="identifier">pass_fail</span></tt>,
                the lexer will behave as if no token has been matched, if is set
                to <tt class="computeroutput"><span class="identifier">lex</span><span class="special">::</span><span class="identifier">pass_flags</span><span class="special">::</span><span class="identifier">pass_ignore</span></tt>, the lexer will ignore
                the current match and proceed trying to match tokens from the input.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_tokenid</span></tt>
              </p></td>
<td><p>
                Refers to the token id of the token to be generated. Any modifications
                to this value will be reflected in the generated token.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_val</span></tt>
              </p></td>
<td><p>
                Refers to the value the next token will be initialized from. Any
                modifications to this value will be reflected in the generated token.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_state</span></tt>
              </p></td>
<td><p>
                Refers to the lexer state the input has been match in. Any modifications
                to this value will be reflected in the lexer itself (the next match
                will start in the new state). The currently generated token is not
                affected by changes to this variable.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">_eoi</span></tt>
              </p></td>
<td><p>
                References the end iterator of the overall lexer input. This value
                cannot be changed.
              </p></td>
</tr>
</tbody>
</table>
</div>
<p>
          The context object passed as the last parameter to any lexer semantic action
          is not directly accessible while using <a href="../../../../../phoenix/doc/html/index.html" target="_top">Boost.Phoenix</a>
          expressions. We rather provide predefine Phoenix functions allowing to
          invoke the different support functions as mentioned above. The following
          table lists the available support functions and describes their functionality:
        </p>
<div class="table">
<a name="id611797"></a><p class="title"><b>Table 11. Support functions usable from Phoenix expressions
        inside lexer semantic actions</b></p>
<table class="table" summary="Support functions usable from Phoenix expressions
        inside lexer semantic actions">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th><p>
                Plain function
              </p></th>
<th><p>
                Phoenix function
              </p></th>
<th><p>
                Description
              </p></th>
</tr></thead>
<tbody>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">more</span><span class="special">()</span></tt>
              </p></td>
<td><p>
                <tt class="computeroutput"><span class="identifier">more</span><span class="special">()</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">more</span><span class="special">()</span></tt> tells the lexer that the next time
                it matches a rule, the corresponding token should be appended onto
                the current token value rather than replacing it.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">less</span><span class="special">()</span></tt>
              </p></td>
<td><p>
                <tt class="computeroutput"><span class="identifier">less</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">less</span><span class="special">()</span></tt> takes a single integer parameter
                <tt class="computeroutput"><span class="identifier">n</span></tt> and returns an
                iterator positioned to the nth input character beyond the current
                token start iterator (i.e. by assigning the return value to the placeholder
                <tt class="computeroutput"><span class="identifier">_end</span></tt> it is possible
                to return all but the first <tt class="computeroutput"><span class="identifier">n</span></tt>
                characters of the current token back to the input stream.
              </p></td>
</tr>
<tr>
<td><p>
                <tt class="computeroutput"><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">lookahead</span><span class="special">()</span></tt>
              </p></td>
<td><p>
                <tt class="computeroutput"><span class="identifier">lookahead</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">)</span></tt>
                or <tt class="computeroutput"><span class="identifier">lookahead</span><span class="special">(</span><span class="identifier">token_def</span><span class="special">)</span></tt>
              </p></td>
<td><p>
                The function <tt class="computeroutput"><span class="identifier">lookahead</span><span class="special">()</span></tt> takes a single parameter specifying
                the token to match in the input. The function can be used for instance
                to implement lookahead for lexer engines not supporting constructs
                like flex' <tt class="computeroutput"><span class="identifier">a</span><span class="special">/</span><span class="identifier">b</span></tt> (match <tt class="computeroutput"><span class="identifier">a</span></tt>,
                but only when followed by <tt class="computeroutput"><span class="identifier">b</span></tt>).
                It invokes the lexer on the input following the current token without
                actually moving forward in the input stream. The function returns
                whether the lexer was able to match the specified token.
              </p></td>
</tr>
</tbody>
</table>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2009 Joel
      de Guzman, Hartmut Kaiser<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="lexer_tokenizing.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../abstracts.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="lexer_static_model.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
