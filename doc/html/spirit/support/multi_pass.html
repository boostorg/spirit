<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> The multi pass iterator</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="../../index.html" title="Spirit 2.1">
<link rel="up" href="../support.html" title=" Supporting libraries">
<link rel="previous" href="../support.html" title=" Supporting libraries">
<link rel="next" href="../faq.html" title=" Spirit FAQ">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../support.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../support.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../faq.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="spirit.support.multi_pass"></a><a href="multi_pass.html" title=" The multi pass iterator"> The multi pass iterator</a>
</h3></div></div>
<div></div>
</div>
<p>
        Backtracking in <span class="emphasis"><em>Spirit.Qi</em></span> requires the use of the following
        types of iterator: forward, bidirectional, or random access. Because of backtracking,
        input iterators cannot be used. Therefore, the standard library classes
        <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istreambuf_iterator</span></tt> and <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span></tt>,
        that fall under the category of input iterators, cannot be used. Another
        input iterator that is of interest is one that wraps a lexer, such as LEX.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          In general, <span class="emphasis"><em>Spirit.Qi</em></span> generates recursive descent
          parser which require backtracking parsers by design. For this reason we
          need to provide at least forward iterators to any of <span class="emphasis"><em>Spirit.Qi</em></span>'s
          API functions. This is not an absolute requirement though. In the future,
          we shall see more deterministic parsers that require no more than 1 character
          (token) of lookahead. Such parsers allow us to use input iterators such
          as the <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span></tt> as is.
        </p></td></tr>
</table></div>
<p>
        Backtracking can be implemented only if we are allowed to save an iterator
        position, i.e. making a copy of the current iterator. Unfortunately, with
        an input iterator, there is no way to do so, and thus input iterators will
        not work with backtracking in <span class="emphasis"><em>Spirit.Qi</em></span>. One solution
        to this problem is to simply load all the data to be parsed into a container,
        such as a vector or deque, and then pass the begin and end of the container
        to <span class="emphasis"><em>Spirit.Qi</em></span>. This method can be too memory intensive
        for certain applications, which is why the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        iterator was created.
      </p>
<a name="spirit.support.multi_pass.using_the_multi_pass"></a><h4>
<a name="id679256"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.using_the_multi_pass">Using the
        multi_pass</a>
      </h4>
<p>
        The <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> iterator will
        convert any input iterator into a forward iterator suitable for use with
        <span class="emphasis"><em>Spirit.Qi</em></span>. <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        will buffer data when needed and will discard the buffer when its contents
        is not needed anymore. This happens either if only one copy of the iterator
        exists or if no backtracking can occur.
      </p>
<p>
        A grammar must be designed with care if the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        iterator is used. Any rule that may need to backtrack, such as one that contains
        an alternative, will cause data to be buffered. The rules that are optimal
        to use are repetition constructs (as kleene and plus).
      </p>
<p>
        Sequences of the form <tt class="computeroutput"><span class="identifier">a</span> <span class="special">&gt;&gt;</span> <span class="identifier">b</span></tt>
        will buffer data as well. This is different from the behaviour of <span class="emphasis"><em>Spirit.Classic</em></span>
        but for a good reason. Sequences need to reset the current iterator to its
        initial state if one of the components of a seqeunce fails to match. To compensate
        for this behaviour we added functionality to the <tt class="computeroutput"><span class="identifier">expect</span></tt>
        parsers (i.e. constructs like <tt class="computeroutput"><span class="identifier">a</span>
        <span class="special">&gt;</span> <span class="identifier">b</span></tt>).
        Expectation points introduce deterministic points into the grammar ensuring
        no backtracking can occur if they match. For this reason we clear the buffers
        of any multi_pass iterator on each expectation point, ensuring minimal buffer
        content even for large grammars.
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td colspan="2" align="left" valign="top">
<p>
          If you use an error handler in conjunction with the <tt class="computeroutput"><span class="identifier">expect</span></tt>
          parser while utilizing a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
          iterator and you intend to use the error handler to force a <tt class="computeroutput"><span class="identifier">retry</span></tt> or a <tt class="computeroutput"><span class="identifier">fail</span></tt>
          (see the description of error handlers - <span class="bold"><b>FIXME</b></span>:
          insert link), then you need to instantiate the error handler using <tt class="computeroutput"><span class="identifier">retry</span></tt> or <tt class="computeroutput"><span class="identifier">fail</span></tt>,
          for instance: 
</p>
<pre class="programlisting"><span class="identifier">rule</span> <span class="identifier">r</span><span class="special">&lt;</span><span class="identifier">iterator_type</span><span class="special">&gt;</span> <span class="identifier">r</span><span class="special">;</span>
<span class="identifier">on_error</span><span class="special">&lt;</span><span class="identifier">retry</span><span class="special">&gt;(</span><span class="identifier">r</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">val</span><span class="special">(</span><span class="string">"Error!"</span><span class="special">));</span>
</pre>
<p>
          If you fail to do so the resulting code will trigger an assert statement
          at runtime.
        </p>
</td></tr>
</table></div>
<p>
        Any rule that repeats, such as kleene_star (<tt class="computeroutput"><span class="special">*</span><span class="identifier">a</span></tt>) or positive such as (<tt class="computeroutput"><span class="special">+</span><span class="identifier">a</span></tt>), will only buffer the data for the current
        repetition.
      </p>
<p>
        In typical grammars, ambiguity and therefore lookahead is often localized.
        In fact, many well designed languages are fully deterministic and require
        no lookahead at all. Peeking at the first character from the input will immediately
        determine the alternative branch to take. Yet, even with highly ambiguous
        grammars, alternatives are often of the form <tt class="computeroutput"><span class="special">*(</span><span class="identifier">a</span> <span class="special">|</span> <span class="identifier">b</span>
        <span class="special">|</span> <span class="identifier">c</span> <span class="special">|</span> <span class="identifier">d</span><span class="special">)</span></tt>.
        The input iterator moves on and is never stuck at the beginning. Let's look
        at a Pascal snippet for example:
      </p>
<pre class="programlisting"><span class="identifier">program</span> <span class="special">=</span>
        <span class="identifier">programHeading</span> <span class="special">&gt;&gt;</span> <span class="identifier">block</span> <span class="special">&gt;&gt;</span> <span class="char">'.'</span>
    <span class="special">;</span>

<span class="identifier">block</span> <span class="special">=</span>
       <span class="special">*(</span>   <span class="identifier">labelDeclarationPart</span>
        <span class="special">|</span>   <span class="identifier">constantDefinitionPart</span>
        <span class="special">|</span>   <span class="identifier">typeDefinitionPart</span>
        <span class="special">|</span>   <span class="identifier">variableDeclarationPart</span>
        <span class="special">|</span>   <span class="identifier">procedureAndFunctionDeclarationPart</span>
        <span class="special">)</span>
    <span class="special">&gt;&gt;</span>  <span class="identifier">statementPart</span>
    <span class="special">;</span>
</pre>
<p>
        Notice the alternatives inside the Kleene star in the rule block . The rule
        gobbles the input in a linear manner and throws away the past history with
        each iteration. As this is fully deterministic LL(1) grammar, each failed
        alternative only has to peek 1 character (token). The alternative that consumes
        more than 1 character (token) is definitely a winner. After which, the Kleene
        star moves on to the next.
      </p>
<p>
        Now, after the lecture on the features to be careful with when using <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>, you may think that <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> is way too restrictive to use.
        That's not the case. If your grammar is deterministic, you can make use of
        the <tt class="computeroutput"><span class="identifier">flush_multi_pass</span></tt> pseudo
        parser in your grammar to ensure that data is not buffered when unnecessary
        (<tt class="computeroutput"><span class="identifier">flush_multi_pass</span></tt> is available
        from the <span class="emphasis"><em>Spirit.Qi</em></span> parser <a href="../../../../repository/doc/html/index.html" target="_top">Repository</a>).
      </p>
<p>
        Here we present a minimal example showing a minimal use case. The <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> iterator is highly configurable,
        but the default policies have been chosen so that its easily usable with
        input iterators such as <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istreambuf_iterator</span></tt>.
        For the complete source code of this example please refer to <a href="../../../../example/support/multi_pass.cpp" target="_top">multi_pass.cpp</a>.
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">namespace</span> <span class="identifier">spirit</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">ascii</span><span class="special">::</span><span class="identifier">char_</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">qi</span><span class="special">::</span><span class="identifier">double_</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">qi</span><span class="special">::</span><span class="identifier">eol</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ifstream</span> <span class="identifier">in</span><span class="special">(</span><span class="string">"multi_pass.txt"</span><span class="special">);</span>    <span class="comment">// we get our input from this file
</span>    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">in</span><span class="special">.</span><span class="identifier">is_open</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Could not open input file: 'multi_pass.txt'"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">-</span><span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istreambuf_iterator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">base_iterator_type</span><span class="special">;</span>
    <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">multi_pass</span><span class="special">&lt;</span><span class="identifier">base_iterator_type</span><span class="special">&gt;</span> <span class="identifier">first</span> <span class="special">=</span> 
        <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">make_default_multi_pass</span><span class="special">(</span><span class="identifier">base_iterator_type</span><span class="special">(</span><span class="identifier">in</span><span class="special">));</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">qi</span><span class="special">::</span><span class="identifier">phrase_parse</span><span class="special">(</span><span class="identifier">first</span>
      <span class="special">,</span> <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">make_default_multi_pass</span><span class="special">(</span><span class="identifier">base_iterator_type</span><span class="special">())</span>
      <span class="special">,</span> <span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;&gt;</span> <span class="identifier">double_</span><span class="special">)</span>              <span class="comment">// recognize list of doubles
</span>      <span class="special">,</span> <span class="identifier">space</span> <span class="special">|</span> <span class="char">'#'</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="identifier">char_</span> <span class="special">-</span> <span class="identifier">eol</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="identifier">eol</span>      <span class="comment">// comment skipper
</span>      <span class="special">,</span> <span class="identifier">v</span><span class="special">);</span>                                       <span class="comment">// data read from file
</span>
    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Failed parsing input file!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">-</span><span class="number">2</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Successfully parsed input file!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
<a name="spirit.support.multi_pass.using_the_flush_multi_pass_parser"></a><h4>
<a name="id681042"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.using_the_flush_multi_pass_parser">Using
        the flush_multi_pass parser</a>
      </h4>
<p>
        The <a href="http://spirit.sourceforge.net" target="_top">Spirit</a> <a href="../../../../repository/doc/html/index.html" target="_top">Repository</a>
        contains the <tt class="computeroutput"><span class="identifier">flush_multi_pass</span></tt>
        parser component. This is usable in conjunction with the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        iterator to minimize the buffering. It allows to insert explicit synchronization
        points into your grammar where it is safe to clear any stored input as it
        is ensured that no backtracking can occur at this point anymore.
      </p>
<p>
        When the <tt class="computeroutput"><span class="identifier">flush_multi_pass</span></tt>
        parser is used with <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>,
        it will call <tt class="computeroutput"><span class="identifier">multi_pass</span><span class="special">::</span><span class="identifier">clear_queue</span><span class="special">()</span></tt>.
        This will cause any buffered data to be erased. This also will invalidate
        all other copies of multi_pass and they should not be used. If they are,
        an <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">illegal_backtracking</span></tt> exception will be
        thrown.
      </p>
<a name="spirit.support.multi_pass.the_multi_pass_policies"></a><h4>
<a name="id681197"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.the_multi_pass_policies">The multi_pass
        Policies</a>
      </h4>
<p>
        The <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> iterator is
        a templated class configurable using policies. The description of <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> above is how it was originally
        implemented (before it used policies), and is the default configuration now.
        But, <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> is capable
        of much more. Because of the open-ended nature of policies, you can write
        your own policy to make <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        behave in a way that we never before imagined.
      </p>
<p>
        The multi_pass class has two template parameters:
      </p>
<div class="variablelist">
<p class="title"><b>The multi_pass template parameters</b></p>
<dl>
<dt><span class="term">Input</span></dt>
<dd><p>
            The type multi_pass uses to acquire it's input. This is typically an
            input iterator, or functor.
          </p></dd>
<dt><span class="term">Policies</span></dt>
<dd><p>
            The combined policies to use to create an instance of a multi_pass iterator.
            This combined policy type is described below
          </p></dd>
</dl>
</div>
<p>
        It is possible to implement all of the required functionality of the combinded
        policy in a single class. But it has shown to be more convenient to split
        this into four different groups of functions, i.e. four separate, but well
        coordinated policies. For this reason the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        library implements a template <tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">default_policy</span></tt>
        allowing to combine several different policies, each implementing one of
        the functionality groups:
      </p>
<div class="table">
<a name="id681361"></a><p class="title"><b>Table 13. Policies needed for default_policy template</b></p>
<table class="table" summary="Policies needed for default_policy template">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th><p>
              Template Parameter
            </p></th>
<th><p>
              Description
            </p></th>
</tr></thead>
<tbody>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">OwnershipPolicy</span></tt>
            </p></td>
<td><p>
              This policy determines how <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              deals with it's shared components.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">CheckingPolicy</span></tt>
            </p></td>
<td><p>
              This policy determines how checking for invalid iterators is done.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">InputPolicy</span></tt>
            </p></td>
<td><p>
              A class that defines how <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              acquires its input. The <tt class="computeroutput"><span class="identifier">InputPolicy</span></tt>
              is parameterized by the <tt class="computeroutput"><span class="identifier">Input</span></tt>
              template parameter to the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">StoragePolicy</span></tt>
            </p></td>
<td><p>
              The buffering scheme used by <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              is determined and managed by the StoragePolicy.
            </p></td>
</tr>
</tbody>
</table>
</div>
<p>
        The <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> library contains
        several predefined policy implementations for each of the policy types as
        described above. First we will describe those predefined types. Afterwards
        we will give some guidelines how you can write your own policy implementations.
      </p>
<a name="spirit.support.multi_pass.predefined_policies"></a><h4>
<a name="id681625"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.predefined_policies">Predefined
        policies</a>
      </h4>
<p>
        All predefined <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        policies are defined in the namespace <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">iterator_policies</span></tt>.
      </p>
<div class="table">
<a name="id681690"></a><p class="title"><b>Table 14. Predefined policy classes</b></p>
<table class="table" summary="Predefined policy classes">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th><p>
              Class name
            </p></th>
<th><p>
              Description
            </p></th>
</tr></thead>
<tbody>
<tr>
<td><p>
              <span class="bold"><b>InputPolicy</b></span> classes
            </p></td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">input_iterator</span></tt>
            </p></td>
<td><p>
              This policy directs <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              to read from an input iterator of type <tt class="computeroutput"><span class="identifier">Input</span></tt>.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">lex_input</span></tt>
            </p></td>
<td><p>
              This policy obtains it's input by calling yylex(), which would typically
              be provided by a scanner generated by <a href="http://flex.sourceforge.net/" target="_top">Flex</a>.
              If you use this policy your code must link against a <a href="http://flex.sourceforge.net/" target="_top">Flex</a>
              generated scanner.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">functor_input</span></tt>
            </p></td>
<td><p>
              This input policy obtains it's data by calling a functor of type <tt class="computeroutput"><span class="identifier">Input</span></tt>. The functor must meet certain
              requirements. It must have a typedef called <tt class="computeroutput"><span class="identifier">result_type</span></tt>
              which should be the type returned from <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>. Also, since an input policy needs
              a way to determine when the end of input has been reached, the functor
              must contain a static variable named <tt class="computeroutput"><span class="identifier">eof</span></tt>
              which is comparable to a variable of <tt class="computeroutput"><span class="identifier">result_type</span></tt>.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">split_functor_input</span></tt>
            </p></td>
<td><p>
              This is essentially the same as the <tt class="computeroutput"><span class="identifier">functor_input</span></tt>
              policy except that the (user supplied) funtion object exposes separate
              <tt class="computeroutput"><span class="identifier">unique</span></tt> and <tt class="computeroutput"><span class="identifier">shared</span></tt> sub classes, allowing to integrate
              the functors <span class="emphasis"><em>unique</em></span> data members with the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> data items held by each
              instance and its <span class="emphasis"><em>shared</em></span> data members will be integrated
              with the <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              members shared by all copies.
            </p></td>
</tr>
<tr>
<td><p>
              <span class="bold"><b>OwnershipPolicy</b></span> classes
            </p></td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">ref_counted</span></tt>
            </p></td>
<td><p>
              This class uses a reference counting scheme. The <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              will delete it's shared components when the count reaches zero.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">first_owner</span></tt>
            </p></td>
<td><p>
              When this policy is used, the first <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              created will be the one that deletes the shared data. Each copy will
              not take ownership of the shared data. This works well for <a href="http://spirit.sourceforge.net" target="_top">Spirit</a>,
              since no dynamic allocation of iterators is done. All copies are made
              on the stack, so the original iterator has the longest lifespan.
            </p></td>
</tr>
<tr>
<td><p>
              <span class="bold"><b>CheckingPolicy</b></span> classes
            </p></td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">no_check</span></tt>
            </p></td>
<td><p>
              This policy does no checking at all.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">buf_id_check</span></tt>
            </p></td>
<td><p>
              This policy keeps around a buffer id, or a buffer age. Every time
              <tt class="computeroutput"><span class="identifier">clear_queue</span><span class="special">()</span></tt>
              is called on a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
              iterator, it is possible that all other iterators become invalid. When
              <tt class="computeroutput"><span class="identifier">clear_queue</span><span class="special">()</span></tt>
              is called, <tt class="computeroutput"><span class="identifier">buf_id_check</span></tt>
              increments the buffer id. When an iterator is dereferenced, this policy
              checks that the buffer id of the iterator matches the shared buffer
              id. This policy is most effective when used together with the <tt class="computeroutput"><span class="identifier">split_std_deque</span></tt> StoragePolicy. It
              should not be used with the <tt class="computeroutput"><span class="identifier">fixed_size_queue</span></tt>
              StoragePolicy, because it will not detect iterator dereferences that
              are out of range.
            </p></td>
</tr>
<tr>
<td><p>
              full_check
            </p></td>
<td><p>
              This policy has not been implemented yet. When it is, it will keep
              track of all iterators and make sure that they are all valid. This
              will be mostly useful for debugging purposes as it will incur significant
              overhead.
            </p></td>
</tr>
<tr>
<td><p>
              <span class="bold"><b>StoragePolicy</b></span> classes
            </p></td>
<td class="auto-generated"> </td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">split_std_deque</span></tt>
            </p></td>
<td><p>
              Despite its name this policy keeps all buffered data in a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></tt>. All data is stored as long
              as there is more than one iterator. Once the iterator count goes down
              to one, and the queue is no longer needed, it is cleared, freeing up
              memory. The queue can also be forcibly cleared by calling <tt class="computeroutput"><span class="identifier">multi_pass</span><span class="special">::</span><span class="identifier">clear_queue</span><span class="special">()</span></tt>.
            </p></td>
</tr>
<tr>
<td><p>
              <tt class="computeroutput"><span class="identifier">fixed_size_queue</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span></tt>
            </p></td>
<td><p>
              This policy keeps a circular buffer that is size <tt class="computeroutput"><span class="identifier">N</span><span class="special">+</span><span class="number">1</span></tt> and
              stores <tt class="computeroutput"><span class="identifier">N</span></tt> elements.
              <tt class="computeroutput"><span class="identifier">fixed_size_queue</span></tt> is
              a template with a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></tt>
              parameter that specified the queue size. It is your responsibility
              to ensure that <tt class="computeroutput"><span class="identifier">N</span></tt> is
              big enough for your parser. Whenever the foremost iterator is incremented,
              the last character of the buffer is automatically erased. Currently
              there is no way to tell if an iterator is trailing too far behind and
              has become invalid. No dynamic allocation is done by this policy during
              normal iterator operation, only on initial construction. The memory
              usage of this <tt class="computeroutput"><span class="identifier">StoragePolicy</span></tt>
              is set at <tt class="computeroutput"><span class="identifier">N</span><span class="special">+</span><span class="number">1</span></tt> bytes, unlike <tt class="computeroutput"><span class="identifier">split_std_deque</span></tt>,
              which is unbounded.
            </p></td>
</tr>
</tbody>
</table>
</div>
<a name="spirit.support.multi_pass.combinations__how_to_specify_your_own_custom_multi_pass"></a><h4>
<a name="id682638"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.combinations__how_to_specify_your_own_custom_multi_pass">Combinations:
        How to specify your own custom multi_pass</a>
      </h4>
<p>
        The beauty of policy based designs is that you can mix and match policies
        to create your own custom iterator by selecting the policies you want. Here's
        an example of how to specify a custom <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        that wraps an <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></tt>,
        and is slightly more efficient than the default <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        (as generated by the <tt class="computeroutput"><span class="identifier">make_default_multi_pass</span><span class="special">()</span></tt> API function) because it uses the <tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">first_owner</span></tt> OwnershipPolicy and the <tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">no_check</span></tt> CheckingPolicy:
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">multi_pass</span><span class="special">&lt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span>
  <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">default_policy</span><span class="special">&lt;</span>
        <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">first_owner</span>
      <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">no_check</span>
      <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">input_iterator</span>
      <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">split_std_deque</span>
    <span class="special">&gt;</span> 
<span class="special">&gt;</span> <span class="identifier">first_owner_multi_pass_type</span><span class="special">;</span>
</pre>
<p>
        The default template parameters for <tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">default_policy</span></tt>
        are:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">ref_counted</span></tt> OwnershipPolicy
        </li>
<li>
<tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">no_check</span></tt> CheckingPolicy, if <tt class="computeroutput"><span class="identifier">BOOST_SPIRIT_DEBUG</span></tt> is defined: <tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">buf_id_check</span></tt> CheckingPolicy
        </li>
<li>
<tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">input_iterator</span></tt> InputPolicy, and
        </li>
<li>
<tt class="computeroutput"><span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">split_std_deque</span></tt> StoragePolicy.
        </li>
</ul></div>
<p>
        So if you use <tt class="computeroutput"><span class="identifier">multi_pass</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span>
        <span class="special">&gt;</span></tt> you will get those pre-defined
        behaviors while wrapping an <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></tt>.
      </p>
<a name="spirit.support.multi_pass.dealing_with_constant_look_ahead"></a><h4>
<a name="id683255"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.dealing_with_constant_look_ahead">Dealing
        with constant look ahead</a>
      </h4>
<p>
        There is one other pre-defined class called <tt class="computeroutput"><span class="identifier">look_ahead</span></tt>.
        The class <tt class="computeroutput"><span class="identifier">look_ahead</span></tt> is another
        predefine <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> iterator
        type. It has two template parameters: <tt class="computeroutput"><span class="identifier">Input</span></tt>,
        the type of the input iterator to wrap, and a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span></tt>, which specifies the size of the buffer
        to the <tt class="computeroutput"><span class="identifier">fixed_size_queue</span></tt> policy.
        While the default multi_pass configuration is designed for safey, <tt class="computeroutput"><span class="identifier">look_ahead</span></tt> is designed for speed. <tt class="computeroutput"><span class="identifier">look_ahead</span></tt> is derived from a multi_pass
        with the following policies: <tt class="computeroutput"><span class="identifier">input_iterator</span></tt>
        InputPolicy, <tt class="computeroutput"><span class="identifier">first_owner</span></tt>
        OwnershipPolicy, <tt class="computeroutput"><span class="identifier">no_check</span></tt>
        CheckingPolicy, and <tt class="computeroutput"><span class="identifier">fixed_size_queue</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">&gt;</span></tt>
        StoragePolicy.
      </p>
<a name="spirit.support.multi_pass.how_to_write_a_functor_for_use_with_the__code__phrase_role__identifier__functor_input__phrase___code__inputpolicy"></a><h4>
<a name="id683470"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.how_to_write_a_functor_for_use_with_the__code__phrase_role__identifier__functor_input__phrase___code__inputpolicy">How
        to write a functor for use with the <tt class="computeroutput"><span class="identifier">functor_input</span></tt>
        InputPolicy</a>
      </h4>
<p>
        If you want to use the <tt class="computeroutput"><span class="identifier">functor_input</span></tt>
        InputPolicy, you can write your own function object that will supply the
        input to <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>. The
        function object must satisfy several requirements. It must have a typedef
        <tt class="computeroutput"><span class="identifier">result_type</span></tt> which specifies
        the return type of its <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>. This is standard practice in the STL.
        Also, it must supply a static variable called eof which is compared against
        to know whether the input has reached the end. Last but not least the function
        object must be default constructible. Here is an example:
      </p>
<pre class="programlisting"><span class="comment">// define the function object
</span><span class="keyword">class</span> <span class="identifier">iterate_a2m</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">char</span> <span class="identifier">result_type</span><span class="special">;</span>

    <span class="identifier">iterate_a2m</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">c</span><span class="special">(</span><span class="char">'A'</span><span class="special">)</span> <span class="special">{}</span>
    <span class="identifier">iterate_a2m</span><span class="special">(</span><span class="keyword">char</span> <span class="identifier">c</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">c_</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">{}</span>

    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">c_</span> <span class="special">==</span> <span class="char">'M'</span><span class="special">)</span>
            <span class="keyword">return</span> <span class="identifier">eof</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">c_</span><span class="special">++;</span>
    <span class="special">}</span>

    <span class="keyword">static</span> <span class="identifier">result_type</span> <span class="identifier">eof</span><span class="special">;</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">char</span> <span class="identifier">c_</span><span class="special">;</span>
<span class="special">};</span>

<span class="identifier">iterate_a2m</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">iterate_a2m</span><span class="special">::</span><span class="identifier">eof</span> <span class="special">=</span> <span class="identifier">iterate_a2m</span><span class="special">::</span><span class="identifier">result_type</span><span class="special">(</span><span class="char">'\0'</span><span class="special">);</span>

<span class="comment">// create two iterators using the define function object, one of which is 
</span><span class="comment">// an end iterator
</span><span class="keyword">typedef</span> <span class="identifier">multi_pass</span><span class="special">&lt;</span><span class="identifier">my_functor</span>
  <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">functor_input</span>
  <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">first_owner</span>
  <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">no_check</span>
  <span class="special">,</span> <span class="identifier">iterator_policies</span><span class="special">::</span><span class="identifier">split_std_deque</span><span class="special">&gt;</span> 
<span class="identifier">functor_multi_pass_type</span><span class="special">;</span>

<span class="identifier">functor_multi_pass_type</span> <span class="identifier">first</span> <span class="special">=</span> <span class="identifier">functor_multi_pass_t</span><span class="special">(</span><span class="identifier">my_functor</span><span class="special">());</span>
<span class="identifier">functor_multi_pass_type</span> <span class="identifier">last</span><span class="special">;</span>

<span class="comment">// use the iterators: this will print "ABCDEFGHIJKL"
</span><span class="keyword">while</span> <span class="special">(</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">first</span><span class="special">;</span>
    <span class="special">++</span><span class="identifier">first</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<a name="spirit.support.multi_pass.how_to_write_policies_for_use_with_multi_pass"></a><h4>
<a name="id684289"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.how_to_write_policies_for_use_with_multi_pass">How
        to write policies for use with multi_pass</a>
      </h4>
<p>
        All policies to be used with the <tt class="computeroutput"><span class="identifier">default_policy</span></tt>
        template need to have two embedded classes: <tt class="computeroutput"><span class="identifier">unique</span></tt>
        and <tt class="computeroutput"><span class="identifier">shared</span></tt>. The <tt class="computeroutput"><span class="identifier">unique</span></tt> class needs to implement all required
        functions for a particular policy type. In addition it may hold all member
        data items being <span class="emphasis"><em>unique</em></span> for a particular instance of
        a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt> (hence the name).
        The <tt class="computeroutput"><span class="identifier">shared</span></tt> class does not
        expose any member functions (except sometimes a constructor), but it may
        hold all member data items to be <span class="emphasis"><em>shared</em></span> between all
        copies of a particular <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>.
      </p>
<a name="spirit.support.multi_pass.inputpolicy"></a><h4>
<a name="id684416"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.inputpolicy">InputPolicy</a>
      </h4>
<p>
        An <tt class="computeroutput"><span class="identifier">InputPolicy</span></tt> must have
        the following interface:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">input_policy</span>
<span class="special">{</span>
    <span class="comment">// Input is the same type used as the first template parameter
</span>    <span class="comment">// while instantiating the multi_pass
</span>    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Input</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">unique</span>
    <span class="special">{</span>
        <span class="comment">// these typedef's will be exposed as the multi_pass iterator
</span>        <span class="comment">// properties
</span>        <span class="keyword">typedef</span> <span class="identifier">__unspecified_type__</span> <span class="identifier">value_type</span><span class="special">;</span>
        <span class="keyword">typedef</span> <span class="identifier">__unspecified_type__</span> <span class="identifier">difference_type</span><span class="special">;</span>
        <span class="keyword">typedef</span> <span class="identifier">__unspecified_type__</span> <span class="identifier">distance_type</span><span class="special">;</span>
        <span class="keyword">typedef</span> <span class="identifier">__unspecified_type__</span> <span class="identifier">pointer</span><span class="special">;</span>
        <span class="keyword">typedef</span> <span class="identifier">__unspecified_type__</span> <span class="identifier">reference</span><span class="special">;</span>

        <span class="identifier">unique</span><span class="special">()</span> <span class="special">{}</span>
        <span class="keyword">explicit</span> <span class="identifier">unique</span><span class="special">(</span><span class="identifier">Input</span><span class="special">)</span> <span class="special">{}</span>

        <span class="comment">// destroy is called whenever the last copy of a multi_pass is
</span>        <span class="comment">// destructed (ownership_policy::release() returned true)
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">destroy</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// swap is called by multi_pass::swap()
</span>        <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique</span><span class="special">&amp;);</span>

        <span class="comment">// advance_input is called whenever the next input character/token
</span>        <span class="comment">// should be fetched. 
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//   t:     is a reference where the next character/token should be 
</span>        <span class="comment">//          stored
</span>        <span class="comment">//
</span>        <span class="comment">// This method is expected to return the parameter t
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">advance_input</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="comment">// input_at_eof is called to test whether this instance is a 
</span>        <span class="comment">// end of input iterator.
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//   t:     is the current token 
</span>        <span class="comment">//
</span>        <span class="comment">// This method is expected to return true if the end of input is 
</span>        <span class="comment">// reached. It is often used in the implementation of the function
</span>        <span class="comment">// storage_policy::is_eof.
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">input_at_eof</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="comment">// input_is_valid is called to verify if the parameter t represents 
</span>        <span class="comment">// a valid input character/token
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//   t:     is the character/token to test for validity
</span>        <span class="comment">// 
</span>        <span class="comment">// This method is expected to return true if the parameter t 
</span>        <span class="comment">// represents a valid character/token.
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">input_is_valid</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">t</span><span class="special">);</span>
    <span class="special">};</span>

    <span class="comment">// Input is the same type used as the first template parameter
</span>    <span class="comment">// while instantiating the multi_pass
</span>    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Input</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">shared</span> 
    <span class="special">{</span>
        <span class="keyword">explicit</span> <span class="identifier">shared</span><span class="special">(</span><span class="identifier">Input</span><span class="special">)</span> <span class="special">{}</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
        It is possible to derive the struct <tt class="computeroutput"><span class="identifier">unique</span></tt>
        from the type <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">default_input_policy</span></tt>. This type implements
        a minimal sufficient interface for some of the required functions, simplifying
        the task of writing a new input policy.
      </p>
<p>
        This class may implement a function <tt class="computeroutput"><span class="identifier">destroy</span><span class="special">()</span></tt> being called during destruction of the
        last copy of a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>.
        This function should be used to free any of the shared data items the policy
        might have allocated during construction of its <tt class="computeroutput"><span class="identifier">shared</span></tt>
        part. Because of the way <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        is implemented any allocated data members in <tt class="computeroutput"><span class="identifier">shared</span></tt>
        should <span class="underline">not</span> be deep copied in a copy
        constructor of <tt class="computeroutput"><span class="identifier">shared</span></tt>.
      </p>
<a name="spirit.support.multi_pass.ownershippolicy"></a><h4>
<a name="id685624"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.ownershippolicy">OwnershipPolicy</a>
      </h4>
<p>
        The <tt class="computeroutput"><span class="identifier">OwnershipPolicy</span></tt> must
        have the following interface:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">ownership_policy</span>
<span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">unique</span>
    <span class="special">{</span>
        <span class="comment">// destroy is called whenever the last copy of a multi_pass is
</span>        <span class="comment">// destructed (ownership_policy::release() returned true)
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">destroy</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// swap is called by multi_pass::swap()
</span>        <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique</span><span class="special">&amp;);</span>

        <span class="comment">// clone is called whenever a multi_pass is copied
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">clone</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// release is called whenever a multi_pass is destroyed
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//
</span>        <span class="comment">// The method is expected to return true if the destructed 
</span>        <span class="comment">// instance is the last copy of a particular multi_pass. 
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">release</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// is_unique is called to test whether this instance is the only 
</span>        <span class="comment">// existing copy of a particular multi_pass
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//
</span>        <span class="comment">// The method is expected to return true if this instance is unique
</span>        <span class="comment">// (no other copies of this multi_pass exist).
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_unique</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>
    <span class="special">};</span>

    <span class="keyword">struct</span> <span class="identifier">shared</span> <span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
        It is possible to derive the struct <tt class="computeroutput"><span class="identifier">unique</span></tt>
        from the type <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">default_ownership_policy</span></tt>. This type implements
        a minimal sufficient interface for some of the required functions, simplifying
        the task of writing a new ownership policy.
      </p>
<p>
        This class may implement a function <tt class="computeroutput"><span class="identifier">destroy</span><span class="special">()</span></tt> being called during destruction of the
        last copy of a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>.
        This function should be used to free any of the shared data items the policy
        might have allocated during construction of its <tt class="computeroutput"><span class="identifier">shared</span></tt>
        part. Because of the way <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        is implemented any allocated data members in <tt class="computeroutput"><span class="identifier">shared</span></tt>
        should <span class="underline">not</span> be deep copied in a copy
        constructor of <tt class="computeroutput"><span class="identifier">shared</span></tt>.
      </p>
<a name="spirit.support.multi_pass.checkingpolicy"></a><h4>
<a name="id686369"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.checkingpolicy">CheckingPolicy</a>
      </h4>
<p>
        The <tt class="computeroutput"><span class="identifier">CheckingPolicy</span></tt> must have
        the following interface:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">checking_policy</span>
<span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">unique</span> 
    <span class="special">{</span>
        <span class="comment">// swap is called by multi_pass::swap()
</span>        <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique</span><span class="special">&amp;);</span>

        <span class="comment">// destroy is called whenever the last copy of a multi_pass is
</span>        <span class="comment">// destructed (ownership_policy::release() returned true)
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">destroy</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// check is called before the multi_pass is dereferenced or 
</span>        <span class="comment">// incremented. 
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//
</span>        <span class="comment">// This method is expected to make sure the multi_pass instance is
</span>        <span class="comment">// still valid. If it is invalid an exception should be thrown.
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">check</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// clear_queue is called whenever the function 
</span>        <span class="comment">// multi_pass::clear_queue is called on this instance
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">clear_queue</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>
    <span class="special">};</span>

    <span class="keyword">struct</span> <span class="identifier">shared</span> <span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
        It is possible to derive the struct <tt class="computeroutput"><span class="identifier">unique</span></tt>
        from the type <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">default_checking_policy</span></tt>. This type implements
        a minimal sufficient interface for some of the required functions, simplifying
        the task of writing a new checking policy.
      </p>
<p>
        This class may implement a function <tt class="computeroutput"><span class="identifier">destroy</span><span class="special">()</span></tt> being called during destruction of the
        last copy of a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>.
        This function should be used to free any of the shared data items the policy
        might have allocated during construction of its <tt class="computeroutput"><span class="identifier">shared</span></tt>
        part. Because of the way <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        is implemented any allocated data members in <tt class="computeroutput"><span class="identifier">shared</span></tt>
        should <span class="underline">not</span> be deep copied in a copy
        constructor of <tt class="computeroutput"><span class="identifier">shared</span></tt>.
      </p>
<a name="spirit.support.multi_pass.storagepolicy"></a><h4>
<a name="id687004"></a>
        <a href="multi_pass.html#spirit.support.multi_pass.storagepolicy">StoragePolicy</a>
      </h4>
<p>
        A <tt class="computeroutput"><span class="identifier">StoragePolicy</span></tt> must have
        the following interface:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">storage_policy</span>
<span class="special">{</span>
    <span class="comment">// Value is the same type as typename MultiPass::value_type
</span>    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">unique</span>
    <span class="special">{</span>
        <span class="comment">// destroy is called whenever the last copy of a multi_pass is
</span>        <span class="comment">// destructed (ownership_policy::release() returned true)
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">destroy</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// swap is called by multi_pass::swap()
</span>        <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique</span><span class="special">&amp;);</span>

        <span class="comment">// dereference is called whenever multi_pass::operator*() is invoked
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//
</span>        <span class="comment">// This function is expected to return a reference to the current
</span>        <span class="comment">// character/token.
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">::</span><span class="identifier">reference</span> <span class="identifier">dereference</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// increment is called whenever multi_pass::operator++ is invoked
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">increment</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">clear_queue</span><span class="special">(</span><span class="identifier">MultiPass</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// is_eof is called to test whether this instance is a end of input 
</span>        <span class="comment">// iterator.
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//
</span>        <span class="comment">// This method is expected to return true if the end of input is 
</span>        <span class="comment">// reached. 
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_eof</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">);</span>

        <span class="comment">// less_than is called whenever multi_pass::operator==() is invoked
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//   rhs:   is the multi_pass reference this instance is compared 
</span>        <span class="comment">//          to
</span>        <span class="comment">//
</span>        <span class="comment">// This function is expected to return true if the current instance
</span>        <span class="comment">// is eual to the right hand side multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">equal_to</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">,</span> <span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>

        <span class="comment">// less_than is called whenever multi_pass::operator&lt;() is invoked
</span>        <span class="comment">//
</span>        <span class="comment">//   mp:    is a reference to the whole multi_pass instance
</span>        <span class="comment">//   rhs:   is the multi_pass reference this instance is compared 
</span>        <span class="comment">//          to
</span>        <span class="comment">//
</span>        <span class="comment">// This function is expected to return true if the current instance
</span>        <span class="comment">// is less than the right hand side multi_pass instance
</span>        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">MultiPass</span><span class="special">&gt;</span>
        <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">less_than</span><span class="special">(</span><span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">mp</span><span class="special">,</span> <span class="identifier">MultiPass</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
    <span class="special">};</span>

    <span class="comment">// Value is the same type as typename MultiPass::value_type
</span>    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Value</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">shared</span> <span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
        It is possible to derive the struct <tt class="computeroutput"><span class="identifier">unique</span></tt>
        from the type <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">default_storage_policy</span></tt>. This type implements
        a minimal sufficient interface for some of the required functions, simplifying
        the task of writing a new storage policy.
      </p>
<p>
        This class may implement a function <tt class="computeroutput"><span class="identifier">destroy</span><span class="special">()</span></tt> being called during destruction of the
        last copy of a <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>.
        This function should be used to free any of the shared data items the policy
        might have allocated during construction of its <tt class="computeroutput"><span class="identifier">shared</span></tt>
        part. Because of the way <tt class="computeroutput"><span class="identifier">multi_pass</span></tt>
        is implemented any allocated data members in <tt class="computeroutput"><span class="identifier">shared</span></tt>
        should <span class="underline">not</span> be deep copied in a copy
        constructor of <tt class="computeroutput"><span class="identifier">shared</span></tt>.
      </p>
<p>
        Generally, a <tt class="computeroutput"><span class="identifier">StoragePolicy</span></tt>
        is the trickiest policy to implement. You should study and understand the
        existing <tt class="computeroutput"><span class="identifier">StoragePolicy</span></tt> classes
        before you try and write your own.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2009 Joel
      de Guzman, Hartmut Kaiser<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../support.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../support.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../faq.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
