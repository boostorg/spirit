<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Warming up</title>
<link rel="stylesheet" href="../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
<link rel="home" href="../../../index.html" title="Spirit 2.1">
<link rel="up" href="../tutorials.html" title="Tutorials">
<link rel="previous" href="quick_start.html" title="Quick Start">
<link rel="next" href="semantic_actions.html" title="Semantic Actions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="quick_start.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorials.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="semantic_actions.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div><div><h4 class="title">
<a name="spirit.karma.tutorials.warming_up"></a><a href="warming_up.html" title="Warming up">Warming up</a>
</h4></div></div>
<div></div>
</div>
<p>
          Learning how to use <span class="emphasis"><em>Spirit.Karma</em></span> is really simple.
          We will start from trivial examples, ramping up as we go.
        </p>
<a name="spirit.karma.tutorials.warming_up.trivial_example__1_generating_a_number"></a><h5>
<a name="id517176"></a>
          <a href="warming_up.html#spirit.karma.tutorials.warming_up.trivial_example__1_generating_a_number">Trivial
          Example #1 Generating a number</a>
        </h5>
<p>
          Let's create a generator that will output a floating-point number:
        </p>
<pre class="programlisting"><span class="identifier">double_</span>
</pre>
<p>
          Easy huh? The above code actually instantiates a Spirit floating point
          generator (a built-in generator). Spirit has many pre-defined generators
          and consistent naming conventions will help you finding your way through
          the maze. Especially important to note is that things related to identical
          entities (as in this case, floating point numbers) are named identically
          in <span class="emphasis"><em>Spirit.Karma</em></span> and in <span class="emphasis"><em>Spirit.Qi</em></span>.
          Actually, both libraries are using the very same variable instance to refer
          to a floating point generator or parser: <tt class="computeroutput"><span class="identifier">double_</span></tt>.
        </p>
<a name="spirit.karma.tutorials.warming_up.trivial_example__2_generating_two_numbers"></a><h5>
<a name="id517254"></a>
          <a href="warming_up.html#spirit.karma.tutorials.warming_up.trivial_example__2_generating_two_numbers">Trivial
          Example #2 Generating two numbers</a>
        </h5>
<p>
          Now, let's create a generator that will output a line consisting of two
          floating-point numbers.
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">&lt;&lt;</span> <span class="identifier">double_</span>
</pre>
<p>
          Here you see the familiar floating-point numeric generator <tt class="computeroutput"><span class="identifier">double_</span></tt> used twice, once for each number.
          If you are used to see the <tt class="computeroutput"><span class="char">'&gt;&gt;'</span></tt>
          operator for concatenating two parsers in <span class="emphasis"><em>Spirit.Qi</em></span>
          you might wonder, what's that <tt class="computeroutput"><span class="char">'&lt;&lt;'</span></tt>
          operator doing in there? We decided to distinguish generating and parsing
          of sequences the same way as the std::stream libraries do: we use operator
          <tt class="computeroutput"><span class="char">'&gt;&gt;'</span></tt> for input (parsing),
          and operator <tt class="computeroutput"><span class="char">'&lt;&lt;'</span></tt> for output
          (generating). Other than that there is no significant difference. The above
          program creates a generator from two simpler generators, glueing them together
          with the sequence operator. The result is a generator that is a composition
          of smaller generators. Whitespace between numbers can implicitly be inserted
          depending on how the generator is invoked (see below).
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            When we combine generators, we end up with a "bigger" generator,
            but it's still a generator. Generators can get bigger and bigger, nesting
            more and more, but whenever you glue two generators together, you end
            up with one bigger generator. This is an important concept.
          </p></td></tr>
</table></div>
<a name="spirit.karma.tutorials.warming_up.trivial_example__3_generating_one_or_more_numbers"></a><h5>
<a name="id517408"></a>
          <a href="warming_up.html#spirit.karma.tutorials.warming_up.trivial_example__3_generating_one_or_more_numbers">Trivial
          Example #3 Generating one or more numbers</a>
        </h5>
<p>
          Now, creating output for two numbers is not too interesting. Let's create
          a generator that will output zero or more floating-point numbers in a row.
        </p>
<pre class="programlisting"><span class="special">*</span><span class="identifier">double_</span>
</pre>
<p>
          This is like a regular-expression Kleene Star. We moved the <tt class="computeroutput"><span class="special">*</span></tt> to the front for the same reasons we did
          in <span class="emphasis"><em>Spirit.Qi</em></span>: we must work with the syntax rules of
          C++. But if you know regular expressions (and for sure you remember those
          C++ syntax rules) it will start to look very familiar in a matter of a
          very short time.
        </p>
<p>
          Any expression that evaluates to a generator may be used with the Kleene
          Star. Keep in mind, though, that due to C++ operator precedence rules you
          may need to put the expression in parentheses for complex expressions.
          As above, whitespace can be inserted implicitely in between the generated
          numbers, if needed.
        </p>
<a name="spirit.karma.tutorials.warming_up.trivial_example__4_generating_a_comma_delimited_list_of_numbers"></a><h5>
<a name="id517497"></a>
          <a href="warming_up.html#spirit.karma.tutorials.warming_up.trivial_example__4_generating_a_comma_delimited_list_of_numbers">Trivial
          Example #4 Generating a comma-delimited list of numbers</a>
        </h5>
<p>
          We follow the lead of <span class="emphasis"><em>Spirit.Qi</em></span>'s warming up section
          and will create a generator that produces a comma-delimited list of numbers.
        </p>
<pre class="programlisting"><span class="identifier">double_</span> <span class="special">&lt;&lt;</span> <span class="special">*(</span><span class="identifier">lit</span><span class="special">(</span><span class="char">','</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">double_</span><span class="special">)</span>
</pre>
<p>
          Notice <tt class="computeroutput"><span class="identifier">lit</span><span class="special">(</span><span class="char">','</span><span class="special">)</span></tt>. It is
          a literal character generator that simply generates the comma <tt class="computeroutput"><span class="char">','</span></tt>. In this case, the Kleene Star is modifying
          a more complex generator, namely, the one generated by the expression:
        </p>
<pre class="programlisting"><span class="special">(</span><span class="identifier">lit</span><span class="special">(</span><span class="char">','</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">double_</span><span class="special">)</span>
</pre>
<p>
          Note that this is a case where the parentheses are necessary. The Kleene
          Star encloses the complete expression above, repeating the whole pattern
          in the generated output zero or more times.
        </p>
<a name="spirit.karma.tutorials.warming_up.let_s_generate_"></a><h5>
<a name="id517696"></a>
          <a href="warming_up.html#spirit.karma.tutorials.warming_up.let_s_generate_">Let's
          Generate!</a>
        </h5>
<p>
          We're done with defining the generator. All what's left is to invoke the
          generator to do its work. For now, we will use the <tt class="computeroutput"><span class="identifier">generate_delimited</span></tt>
          function. One overload of this function accepts four arguments:
        </p>
<div class="orderedlist"><ol type="1">
<li>
            An output iterator accepting the generated characters
          </li>
<li>
            The generator expression
          </li>
<li>
            Another generator called the delimiting generator
          </li>
<li>
            The data to format and output
          </li>
</ol></div>
<p>
          While comparing this minimal example with an equivalent parser example
          we notice a significant difference. It is possible (and actually, it makes
          a lot of sense) to use a parser without creating any internal representation
          of the parsed input (i.e. without 'producing' any data from the parsed
          input). Using a parser in this mode checks the provided input against the
          given parser expression allowing to verify whether the input is parsable.
          For generators this mode doesn't make any sense. What is output generation
          without generating any output? So we always will have to supply the data
          the output should be generated from. In our example we supply a vector
          of <tt class="computeroutput"><span class="keyword">double</span></tt> numbers as the last
          parameter to the function <tt class="computeroutput"><span class="identifier">generate_delimited</span></tt>
          (see code below).
        </p>
<p>
          In this example, we wish to delimit the generated numbers by spaces. Another
          generator named <tt class="computeroutput"><span class="identifier">space</span></tt> is
          included in Spirit's repertoire of predefined generators. It is a very
          trivial generator that simply produces spaces. It is the equivalent to
          writing <tt class="computeroutput"><span class="identifier">lit</span><span class="special">(</span><span class="char">' '</span><span class="special">)</span></tt>, or simply
          <tt class="computeroutput"><span class="char">' '</span></tt>. It has been implemented
          for similarity with the corresponding predefined <tt class="computeroutput"><span class="identifier">space</span></tt>
          parser. We will use <tt class="computeroutput"><span class="identifier">space</span></tt>
          as our delimiter. The delimiter is the one responsible for inserting characters
          in between generator elements such as the <tt class="computeroutput"><span class="identifier">double_</span></tt>
          and <tt class="computeroutput"><span class="identifier">lit</span></tt>.
        </p>
<p>
          Ok, so now let's generate (for the complete source code of this example
          please refer to <a href="../../../../../example/karma/num_list1.cpp" target="_top">num_list1.cpp</a>).
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">OutputIterator</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">generate_numbers</span><span class="special">(</span><span class="identifier">OutputIterator</span> <span class="identifier">sink</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">karma</span><span class="special">::</span><span class="identifier">double_</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">karma</span><span class="special">::</span><span class="identifier">generate_delimited</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">ascii</span><span class="special">::</span><span class="identifier">space</span><span class="special">;</span>

    <span class="keyword">bool</span> <span class="identifier">r</span> <span class="special">=</span> <span class="identifier">generate_delimited</span><span class="special">(</span>
        <span class="identifier">sink</span><span class="special">,</span>                           <span class="callout_bug"><a name="spirit4co" href="warming_up.html#spirit4"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
        <span class="identifier">double_</span> <span class="special">&lt;&lt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&lt;&lt;</span> <span class="identifier">double_</span><span class="special">),</span>   <span class="callout_bug"><a name="spirit5co" href="warming_up.html#spirit5"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
        <span class="identifier">space</span><span class="special">,</span>                          <span class="callout_bug"><a name="spirit6co" href="warming_up.html#spirit6"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
        <span class="identifier">v</span>                               <span class="callout_bug"><a name="spirit7co" href="warming_up.html#spirit7"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
    <span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">r</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
          </p>
<p>
            </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit4"></a><a href="#spirit4co"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> destination: output iterator </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit5"></a><a href="#spirit5co"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> the generator </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit6"></a><a href="#spirit6co"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> the delimiter-generator </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="spirit7"></a><a href="#spirit7co"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> the
            data to output </p></td>
</tr>
</table></div>
<p>
          </p>
<p>
        </p>
<p>
          The generate function returns <tt class="computeroutput"><span class="keyword">true</span></tt>
          or <tt class="computeroutput"><span class="keyword">false</span></tt> depending on the
          result of the output generation. As outlined in different places of this
          documentation, a generator may fail for different reasons. One of the possible
          reasons is an error in the underlying output iterator (memory exhausted
          or disk full, etc.). Another reason might be that the data doesn't match
          the requirements of a particular generator.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top">
<p>
            <tt class="computeroutput"><span class="keyword">char</span></tt> and <tt class="computeroutput"><span class="keyword">wchar_t</span></tt>
            operands
          </p>
<p>
            The careful reader may notice that the parser expression has <tt class="computeroutput"><span class="char">','</span></tt> instead of <tt class="computeroutput"><span class="identifier">lit</span><span class="special">(</span><span class="char">','</span><span class="special">)</span></tt>
            as the previous examples did. This is ok due to C++ syntax rules of conversion.
            Spirit provides <tt class="computeroutput"><span class="special">&lt;&lt;</span></tt>
            operators that are overloaded to accept a <tt class="computeroutput"><span class="keyword">char</span></tt>
            or <tt class="computeroutput"><span class="keyword">wchar_t</span></tt> argument on its
            left or right (but not both). An operator may be overloaded if at least
            one of its parameters is a user-defined type. In this case, the <tt class="computeroutput"><span class="identifier">double_</span></tt> is the 2nd argument to <tt class="computeroutput"><span class="keyword">operator</span><span class="special">&lt;&lt;</span></tt>,
            and so the proper overload of <tt class="computeroutput"><span class="special">&lt;&lt;</span></tt>
            is used, converting <tt class="computeroutput"><span class="char">','</span></tt> into
            a character literal parser.
          </p>
<p>
            The problem with omiting the <tt class="computeroutput"><span class="identifier">lit</span></tt>
            should be obvious: <tt class="computeroutput"><span class="char">'a'</span> <span class="special">&lt;&lt;</span>
            <span class="char">'b'</span></tt> is not a spirit generator, it
            is a numeric expression, left-shifting the ASCII (or another encoding)
            value of <tt class="computeroutput"><span class="char">'a'</span></tt> by the ASCII value
            of <tt class="computeroutput"><span class="char">'b'</span></tt>. However, both <tt class="computeroutput"><span class="identifier">lit</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">&lt;&lt;</span>
            <span class="char">'b'</span></tt> and <tt class="computeroutput"><span class="char">'a'</span>
            <span class="special">&lt;&lt;</span> <span class="identifier">lit</span><span class="special">(</span><span class="char">'b'</span><span class="special">)</span></tt>
            are Spirit sequence generators for the letter <tt class="computeroutput"><span class="char">'a'</span></tt>
            followed by <tt class="computeroutput"><span class="char">'b'</span></tt>. You'll get
            used to it, sooner or later.
          </p>
</td></tr>
</table></div>
<p>
          Note that we inlined the generator directly in the call to <tt class="computeroutput"><span class="identifier">generate_delimited</span></tt>. Upon calling this
          function, the expression evaluates into a temporary, unnamed generator
          which is passed into the <tt class="computeroutput"><span class="identifier">generate_delimited</span></tt>
          function, used, and then destroyed.
        </p>
<p>
          Here, we chose to make the generate function generic by making it a template,
          parameterized by the output iterator type. By doing so, it can put the
          generated data into any STL conforming output iterator.
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001-2009 Joel
      de Guzman, Hartmut Kaiser<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="quick_start.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorials.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="semantic_actions.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
