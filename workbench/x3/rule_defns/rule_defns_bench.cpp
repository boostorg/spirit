//OriginalSource:
//  ./rule_defns.cpp
//  [spirit]
//    https://github.com/boostorg/spirit/tree/develop
//  [toy]
//    [spirit]/workbench/x3/toy/toy.cpp
//  [detail_rule]
//    [spirit]/include/boost/spirit/home/x3/nonterminal/detail/rule.hpp
//  [context]
//    [spirit]/include/boost/spirit/home/x3/support/context.hpp
//  [calc1]
//    http://www.boost.org/doc/libs/1_61_0/libs/spirit/example/qi/compiler_tutorial/calc1.cpp
//Purpose:
//  A compile time benchmark for various methods of linking a rule
//  with it's RHS.
//Author:
//  Larry Joe Evans, 2016-12-31.
//===============
#include "operators.hpp"

#include <cassert>
#include <boost/core/demangle.hpp>
#include <typeinfo>
  template
  < typename Type
  >
  std::string
type_name()
  {
    return boost::core::demangle(typeid(Type).name());
  }  
#include <utility>
#include <cstring>
#include <boost/type_traits/is_same.hpp>
#include <boost/spirit/home/x3/support/unused.hpp>
#include <boost/preprocessor/variadic/to_seq.hpp>
#include <boost/preprocessor/variadic/elem.hpp>
#include <boost/preprocessor/seq/for_each.hpp>
      template 
      < typename ID
      , typename RHS
      >
    struct rule_definition
      ;
    template <typename ID>
    struct rule
      ;

#include "RULE2RHS_METHODS.hpp"
#define USE_RHS_DEF \
     RULE2RHS_WHICH == RULE2RHS_CTX_LIST \
  || RULE2RHS_WHICH == RULE2RHS_CTX_MI_REC \
  || RULE2RHS_WHICH == RULE2RHS_GET_RHS_REC
#define RULE2RHS_GET_RHS_ANY \
     RULE2RHS_WHICH == RULE2RHS_GET_RHS_REC \
  || RULE2RHS_WHICH == RULE2RHS_GET_RHS_ALL
#define RULE2RHS_CTX_MI_ANY \
     RULE2RHS_WHICH == RULE2RHS_CTX_MI_REC \
  || RULE2RHS_WHICH == RULE2RHS_CTX_MI_ALL

    namespace detail_rule
    {
      struct rule_undefined
        /**@brief
         *  Tag value indicating a rule has not been defined.
         */
        {
            template <typename Iterator, typename Context>
            bool parse(Iterator& first, Iterator last, Context const& ctx) const
            /*! \brief 
             *    Prevent redundant compiletime error in default parse_rule
             *    when static_assert fires.
             */
            {
                assert(false);
                return false;
            }
        };
        
    
    }//detail_rule namespace
    
  //#define REPORT_CONTEXT_SIZE
  #ifdef REPORT_CONTEXT_SIZE
      template<typename Context>
      std::size_t 
    context_size(Context const&ctx)
      { return 0;
      }
  #endif
  #if RULE2RHS_WHICH == RULE2RHS_CTX_LIST    
    
    namespace detail_rule
    {
     //OriginalSource:
     //  [detail_rule]
        // we use this so we can detect if the default parse_rule
        // is the being called.
        struct default_parse_rule_result
        {
            default_parse_rule_result(bool r=false)
              : r(r) {}
            operator bool() const { return r; }
            bool r;
        };
    }//detail_rule namespace
    
    /*! \brief Default parse_rule implementation.
     *  parse_rule's specialized for a particular
     *  rule<ID> are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      , typename Iterator
      , typename Context
      >
    inline detail_rule::default_parse_rule_result
    parse_rule(
        rule<ID> rule_
      , Iterator& first
      , Iterator const& last
      , Context const& ctx
      )
    ;
#ifdef USE_TRACING
  #define PARSE_RULE_SPECIALIZED_TRACE_INOUT trace_scope ts(std::string(__func__)+".specialized_yes");
  #define PARSE_RULE_SPECIALIZED_TRACE_RESULT std::cout<<":result="<<result<<"\n";
#else
  #define PARSE_RULE_SPECIALIZED_TRACE_INOUT
  #define PARSE_RULE_SPECIALIZED_TRACE_RESULT
#endif

/*!
  \def BOOST_SPIRIT_DEFINE_(r, data, rule_name)
    \a r is ignored.
    \a data is ignored.
    \a rule_name is the variable name of a variable
       with type, rule<ID>.
    The macro generates an instance of parse_rule
    specialized on decltype(rule_name) as 1st arg.  The body
    calls BOOST_PP_CAT(rule_name,_def) which, of course,
    must be defined before this macro is executed.
    ***For example, if rule_name is x, then there must be
    declared, x_def, in the scope "surrounding" the call
    to this macro.***
    This macro differs from that in [rule] because
    it does *not* call rule_name::operator=.  The reason
    it does not is because, for this file, only parsing
    and no attributes are needed.  The actual
    BOOST_SPIRIT_DEFINE_ calls rule_definitions.
    *Maybe* this is needed for attribute processing, but
    here, there are no attributes.
*/
#define BOOST_SPIRIT_DEFINE_(r, data, rule_name)                                \
    template <typename Iterator, typename Context>                              \
    inline bool parse_rule(                                                     \
        decltype(rule_name)                                                     \
      , Iterator& first, Iterator const& last                                   \
      , Context const& context)                                                 \
    {                                                                           \
        PARSE_RULE_SPECIALIZED_TRACE_INOUT                                      \
        auto const&def=BOOST_PP_CAT(rule_name, _def);                           \
        bool result=def.parse( first, last, context);                           \
        PARSE_RULE_SPECIALIZED_TRACE_RESULT                                     \
        return result;                                                          \
    }                                                                           \
    /***/
#define BOOST_SPIRIT_DEFINE(...) BOOST_PP_SEQ_FOR_EACH(                         \
    BOOST_SPIRIT_DEFINE_, _, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))             \
    /***/
///////////////////////////////////////////////////////////////////////////////
/**
 * \defgroup link_rule_to_rhs_by_context-list.
 * @{
 */
//Purpose:
//  This code stores the rule definition in the
//  parser context argument incrementally.
//  It does this somewhat like the current spirit(2016-07-28) does., AFAICT.
//CopiedModifiedFrom:
//  [toy] and [context].  The [toy] part was modified to
//  prevention duplication of context entries as done
//  by [context].
// 
    template <typename ID, typename T, typename NextContext>
    struct context
    {
        context(T const& val, NextContext const& next_ctx)
            : val(val), next_ctx(next_ctx) {}

        T const& get(mpl::identity<ID>) const
        {
            return val;
        }

        template <typename Identity>
        decltype(std::declval<NextContext>().get(Identity()))
        get(Identity id) const
        {
            return next_ctx.get(id);
        }

        T const& val;
        NextContext const& next_ctx;
    };

    struct empty_context
    {
        template <typename ID>
        detail_rule::rule_undefined get(ID) const
        {
            return detail_rule::rule_undefined();
        }
    };
    
    #ifdef REPORT_CONTEXT_SIZE
            template <typename ID, typename T, typename NextContext>
        std::size_t 
      context_size(context<ID,T,NextContext>const& ctx)
        { return 1+context_size(ctx.next_ctx);
        }
    #endif
    
    /**
     * \defgroup context
     * @{
     */
    //The following code was just copy&pasted from [context]
    //with slight adaptaiion to the above context definitions.
    template <typename Tag, typename Context>
    inline decltype(auto) get(Context const& context)
    {
        return context.get(mpl::identity<Tag>());
    }
    
    /*! \brief Default parse_rule implementation.
     *  parse_rule's specialized for a particular
     *  rule<ID> are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      , typename Iterator
      , typename Context
      >
    inline detail_rule::default_parse_rule_result
    parse_rule(
        rule<ID> rule_
      , Iterator& first
      , Iterator const& last
      , Context const& ctx
      )
    {
    #ifdef USE_TRACING
      trace_scope ts(std::string(__func__)+".specialized_not");
    #endif
      auto const&parser=get<ID>(ctx);
      constexpr bool is_undefined
        =is_same<decltype(get<ID>(ctx)), detail_rule::rule_undefined>::value;
    #if 1
      static_assert
        ( !is_undefined
        , "BOOST_SPIRIT_DEFINE undefined for this rule."
        );
    #endif
      bool result=parser.parse(first, last, ctx);
    #ifdef USE_TRACING
      std::cout<<":result="<<result<<"\n";
    #endif
      return {result};
    }
    
    namespace detail_make_unique
    {
        template <typename ID, typename T, typename Next, typename FoundVal>
        inline Next const&
        make_unique_context(T& val, Next const& next, FoundVal&)
        {
            return next;
        }
        
        template <typename ID, typename T, typename Next>
        inline context<ID, T, Next>
        make_unique_context(T& val, Next const& next, detail_rule::rule_undefined)
        {
            return { val, next };
        }
    }
    
    template <typename ID, typename T, typename Next>
    inline auto
    make_unique_context(T& val, Next const& next)
    {
        return detail_make_unique::make_unique_context<ID>(val, next, get<ID>(next));
    }    
    /** @}*/ //defgroup context
  
    namespace detail_rule
    {
     //OriginalSource:
     //  [detail_rule].make_rule_context
        template <typename RhsInContext, typename OrigContext>
        auto const&
        make_rule_context
        ( mpl::true_ //is_default_parse_rule
        , RhsInContext const& rhs_in_context //==make_unique_context<ID>(rhs, orig_context);
        , OrigContext  const& orig_context
        )
        {
            return rhs_in_context
              //BOOST_SPIRIT_DEFINE has *not* been done for the rule;
              //hence, inject the rule ID->rhs into context.
              ;
        }
        template <typename RhsInContext, typename OrigContext>
        auto const&
        make_rule_context
        ( mpl::false_ //is_default_parse_rule
        , RhsInContext const& rhs_in_context
        , OrigContext  const& orig_context
        )
        {
            return orig_context
              //BOOST_SPIRIT_DEFINE has been done for the rule;
              //hence, no need to inject the ruled ID->rhs into context.
              ;
        }
    
     //OriginalSource:
     //  [detail_rule].rule_parser::parse_rhs_main
        template <typename ID, typename RHS, typename Iterator, typename Context
          >
        bool parse_rhs_main(
            RHS const& rhs
          , Iterator& first, Iterator const& last
          , Context const& context
          )
        {
            #ifdef USE_TRACING
              trace_scope ts(std::string(__func__));
            #endif
            // see if the user has a BOOST_SPIRIT_DEFINE for this rule
            auto rhs_in_context=make_unique_context<ID>(rhs, context);
            typedef
                decltype(parse_rule(
                    rule<ID>(), first, last
                  , rhs_in_context))
            parse_rule_result;

            // If there is no BOOST_SPIRIT_DEFINE for this rule,
            // we'll make a context for this rule tagged by its ID
            // so we can extract the rule later on in the default
            // (generic) parse_rule function.
            typedef
                is_same<parse_rule_result, default_parse_rule_result>
            is_default_parse_rule;

            Iterator i = first;
            bool r = rhs.parse(
                i
              , last
              , make_rule_context(is_default_parse_rule{},rhs_in_context,context)
            );

            if (r)
                first = i;
            return r;
        }
    }//detail_rule namespace
    
/** @}*/ //defgroup link_rule_to_rhs_by_context-list.
  #elif RULE2RHS_WHICH == RULE2RHS_CTX_MI_REC \
     || RULE2RHS_WHICH == RULE2RHS_CTX_MI_ALL
///////////////////////////////////////////////////////////////////////////////
/**
 * \defgroup link_rule_to_rhs_by_multi-inheritance
 * @{
 */
//Purpose:
//  This code uses multi-inheritance to record the link between
//  a rule<ID> and it's rule_definition.
//  It's not in current spirit (2016-07-28), AFAICT.

      template
      < typename... RuleDefinition
      >
      struct
    rule_defns
      ;
    #ifdef REPORT_CONTEXT_SIZE
        template <typename... RuleDefinition>
        std::size_t 
      context_size(rule_defns<RuleDefinition...>const& ctx)
        { return sizeof...(RuleDefinition);
        }
    #endif
      template
      < typename... ID
      , typename... RHS
      >
    struct rule_defns
      < rule_definition
        < ID
        , RHS
        >...
      >
      : rule_definition
        < ID
        , RHS
        >...
      {
      private:
          template
          < typename GetId
          >
            static
          auto constexpr
        get_def_impl
          ( ... //overload resolution prefers anything over ...
          )
          /**@brief
           *  No rule_definition< GetId, RHS> in superclasses.
           */
          {
              return detail_rule::rule_undefined();
          }
          template
          < typename GetID
          , typename GetRHS
          >
            static
          auto constexpr
        get_def_impl
          ( rule_definition
            < GetID
            , GetRHS
            >const* a_def
          )
          /**@brief
           *  Only used by member function, get_def()const.
           */
          {
              return *a_def;
          }
      public:
          template
          < typename GetID
          >
          auto  constexpr
        get_def()const
          /**@brief
           *  retrieve the definition of AnVarble.
           */
          {
            return get_def_impl<GetID>(this);
          }
        template<typename... Defs>
        rule_defns(Defs... defs)
          : rule_definition
            < ID
            , RHS
            >(defs)...
          {}
        
      };//rule_defns
      template
      < typename ID
      , typename... RuleDefinition
      >
      auto
    get
      ( rule_defns<RuleDefinition...>const& defs
      )
      {
      #ifdef USE_TRACING
        trace_scope ts(std::string(__func__)+"<"+type_name<ID>()+">");
      #endif
        return defs.template get_def<ID>();
      }
    using empty_context=rule_defns<>;
      template
      < typename... ID
      , typename... RHS
      >
      auto
    make_defs
      ( rule_definition< ID, RHS>... defs
      )
      {
        #ifdef USE_TRACING
          trace_scope ts(std::string(__func__));
        #endif
          return 
            rule_defns
            < rule_definition< ID, RHS>...
            >(defs...);
      }
    
/** @}*/
  #elif RULE2RHS_GET_RHS_ANY
  
    namespace detail_rule
    {
        template <typename ID>
        struct always_false
        {
            static constexpr bool value=false;
        };
    }//detail_rule namespace
    
    /*! \brief Default get_rhs implementation.
     *  get_rhs' specialized for a particular
     *  ID are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      >
      auto const&
    get_rhs
      ( ID
      )
      {
        static_assert
          ( detail_rule::always_false<ID>::value
            //Using just false in the above causes assert to
            //always fire.  Using the above template
            //metafunction call avoids that.
          , "Undefined rule.  Use BOOST_SPIRIT_DEFINE to define rule."
          );
        using rhs_t=detail_rule::rule_undefined;
        static rhs_t rhs_v;
        return rhs_v;
      }
/*!
  \def BOOST_SPIRIT_DEFINE_(r, data, rule_def)
    \a r is ignored.
    \a data is ignored.
    \a rule_def is the variable name of a variable
       with type, rule_definition<ID>.
    This macro generates an instance of get_rhs(ID)
    specialized on decltype(rule_def)::rule_id(==ID) as 1st arg.  
    The body just returns this variable.  Of course this
    means rule_def must be defined before this macro is executed.
    For example, if x is the rule variable named x, then a
    declaration statement something like:
      auto const& x_def = x = rhs;
    must occur in the scope in which this macro is invoked.
    Then, this macro is called as:
      BOOST_SPIRIT_DEFINE_(_,_,x_def)
*/
#define BOOST_SPIRIT_DEFINE_(r, data, rule_def) \
      auto const&                                \
    get_rhs                                      \
      ( typename decltype(rule_def)::rule_id     \
      )                                          \
    {                                            \
        return rule_def;                         \
    }                                            \
  
#define BOOST_SPIRIT_DEFINE(...) BOOST_PP_SEQ_FOR_EACH(                        \
    BOOST_SPIRIT_DEFINE_, _, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))            \
    /***/
    
    struct empty_context{};
    
  #endif//RULE2RHS_WHICH == RULE2RHS_CTX_LIST
    
      template 
      < typename ID
      , typename RHS
      >
    struct rule_definition 
      : parser
        < rule_definition
          < ID
          , RHS
          >
        >
    {
      #if RULE2RHS_GET_RHS_ANY
        using rule_id=ID;
      #endif
        
        rule_definition(RHS const& rhs)
          : rhs(rhs){}
        
          template <typename Iterator, typename Context>
          bool 
        parse
          ( Iterator& first
          , Iterator last
          , Context const& ctx
          ) const
        {
        #ifdef USE_TRACING
	  std::ostringstream os;
	  os<<*this;
	  os<<"::parse";
	  std::string str=os.str();
	  trace_scope ts(str);
        #endif
        #ifdef REPORT_CONTEXT_SIZE
          std::cout<<__func__
            <<" in rule_definition<"<<ID::our_id<<">"
            <<":context_size="<<context_size(ctx)<<"\n";
        #endif
        #if RULE2RHS_WHICH == RULE2RHS_CTX_LIST
          bool result=detail_rule::parse_rhs_main<ID>
            ( rhs, first, last, ctx);
        #else
          bool result=rhs.parse( first, last, ctx);
        #endif
          return result;
        }
        
        RHS rhs;

        friend std::ostream&
	operator<<(std::ostream& os, rule_definition<ID,RHS>const&p)
        {
	    os<<"rule_definition<"<<type_name<ID>()<<">";
	    return os;
        }
    };//rule_definition struct

    template <typename ID>
    struct rule : parser<rule<ID>>
    {
        rule(){}
        
        template <typename Derived>
        rule_definition<ID, Derived>
        operator=(parser<Derived> const& definition) const
        {
            return rule_definition<ID, Derived>(definition.derived());
        }

        template <typename Iterator, typename Context>
        bool parse(Iterator& first, Iterator last, Context const& ctx) const
        {
        #ifdef USE_TRACING
	  std::ostringstream os;
	  os<<type_name<rule<ID> >();
	  os<<"::parse";
	  std::string str=os.str();
	  trace_scope ts(str);
        #endif
        #ifdef REPORT_CONTEXT_SIZE
          std::cout<<__func__
            <<"in rule<"<<ID::our_id<<">"
            <<":context_size="<<context_size(ctx)<<"\n";
        #endif
        #if RULE2RHS_GET_RHS_ANY
          auto const&def=get_rhs(ID{});
          bool result=def.parse(first, last, ctx);
        #elif RULE2RHS_CTX_MI_ANY
          auto const&def=get<ID>(ctx);
          bool result=def.parse(first, last, ctx);
        #else
          bool result=parse_rule(*this, first, last, ctx);
        #endif
        #ifdef USE_TRACING
	  std::cout<<":result="<<result<<"\n";
        #endif
	  return result;
        }
        
        friend std::ostream&
	operator<<(std::ostream& os, rule<ID>const&p)
        {
          os<<type_name<ID>();
          return os;
        }
    };//rule struct
    
///////////////////////////////////////////////////////////////////////////////
// test code

template <typename Iterator, typename Derived, typename Context=empty_context>
inline bool parse(parser<Derived> const& p, Iterator& first, Iterator last, Context ctx=Context())
{
   return p.derived().parse(first, last, ctx);
}

template <typename Parser, typename Context=empty_context>
void test_parse(unsigned parse_count, Parser const& p, char const* in, Context ctx=Context())
{
    trace_scope ts(std::string(__func__)+":parse_count="+std::to_string(parse_count));
    std::cout<<":in.beg="<<in<<"\n";
    char const*const end=in + std::strlen(in);
    auto result=parse(p, in, end, ctx);
    while(result && in != end) result=parse(p, in, end, ctx);
    std::cout<<__func__<<":in.end="<<in<<"\n";
    std::cout<<__func__<<":result="<<result<<"\n";
}

namespace gram_bench
{
#define GRAM_BENCH
#if defined(GRAM_BENCH)
    template<unsigned ID> 
    struct id //rule id's.
    {  static auto constexpr our_id=ID;
    };
    //methods where mostly r_I_def used on rhs.
  //#define USE_GRAM_FILE
  #ifdef USE_GRAM_FILE
    #include "gram_file.hpp"
  #else
    #pragma message("!defined(USE_GRAM_FILE)")
    
    //The above #pragma is to safeguard against repeated
    //runs with larger and larger number of rules in
    //gram_file.hpp ; yet, not seeing any difference in the
    //timing for the various methods.  Without this,
    //someone, such as the orig author, could spend hours
    //trying to figure out why there was no difference in
    //performance amoung the various methods :(
    
    //The following grammar is based on a simple aritmetic
    //expression grammar, such as the one in [calc1]:
    //=====================================================
    enum eid //provide more meaningful names for rule id's.
      :unsigned
      { fact
      , term
      , expr
      };
    rule<id<fact>> const r_0;
    rule<id<term>> const r_1;
    rule<id<expr>> const r_2;
    char const*const op[expr+1]=
      { "_" //corresponds to uint_ in [calc1]
      , "1" //corresponds to * operator in [calc1]
      , "2" //corresponds to + operator in [calc1]
      };
  #if USE_RHS_DEF
    auto const r_0_def = r_0 =
          string_(op[0])
        |    char_('[') 
          >> r_2 //can't use r_2_def here because not yet defined.
          >> char_(']')
        ; 
   
    auto const r_1_def = r_1 =
           r_0_def
        >> *( string_(op[1]) 
              >> r_0_def
            )
        ;

    auto const r_2_def = r_2 =
           r_1_def
        >> *( string_(op[2])  
            >> r_1_def
            )
        ;
    auto const& start=r_2_def;
    #if RULE2RHS_WHICH == RULE2RHS_CTX_MI_REC
      auto const& ctx=make_defs
        ( r_2_def
        );
    #else
      auto const ctx = empty_context();
      #if RULE2RHS_WHICH == RULE2RHS_GET_RHS_REC
        BOOST_SPIRIT_DEFINE
          ( r_2_def
          );
      #else//RULE2RHS_CTX_LIST
      #endif
    #endif//RULE2RHS_CTX_MI_REC
  #else//!USE_RHS_DEF
    auto const r_0_def = r_0 =
          string_(op[0])
        |    char_('[') 
          >> r_2 //can't use r_2_def here because not yet defined.
          >> char_(']')
        ; 
   
    auto const r_1_def = r_1 =
           r_0
        >> *( string_(op[1])
              >> r_0
            )
        ;

    auto const r_2_def = r_2 =
           r_1
        >> *( string_(op[2])
            >> r_1
            )
        ;
    auto const& start=r_2;
    #if RULE2RHS_WHICH == RULE2RHS_CTX_MI_ALL
      auto const& ctx=make_defs
        ( r_0_def
        , r_1_def
        , r_2_def
        );
    #else//RULE2RHS_GET_RHS_ALL
      auto const ctx = empty_context();
      BOOST_SPIRIT_DEFINE
        ( r_0_def
        , r_1_def
        , r_2_def
        );
    #endif//endif:RULE2RHS_CTX_MI_ALL
  #endif//endif:USE_RHS_DEF
  #endif//USE_GRAM_FILE
  void run()
  {
    using namespace gram_bench;
    trace_scope ts("gram_bench");
    unsigned parse_count=0;
    //test_parse(parse_count++,start, "_", ctx) ;
    test_parse(parse_count++,start, "_1_1[_2_]1_2_", ctx) ;
    std::cout << "==========================================" << std::endl;
  }
#else
    void run(){}  
#endif //GRAM_BENCH
}//exit gram_bench namespace
int main()
{

    iostreams::indent_scoped_ostreambuf<char>
  indent_outbuf(std::cout,2);
  #ifdef USE_TRACING
  std::cout<<"yes defined(USE_TRACING)\n";
  #else
  std::cout<<"not defined(USE_TRACING)\n";
  #endif
  #ifdef USE_IOSTREAMS_UTILITY
  std::cout<<"yes defined(USE_IOSTREAMS_UTILITY)\n";
  #else
  std::cout<<"not defined(USE_IOSTREAMS_UTILITY)\n";
  #endif
  #ifdef USE_GRAM_FILE
  std::cout<<"yes defined(USE_GRAM_FILE)\n";
  #else
  std::cout<<"not defined(USE_GRAM_FILE)\n";
  #endif
  std::cout<<"RULE2RHS_WHICH="<<rule2rhs_name[RULE2RHS_WHICH]<<"\n";
  gram_bench::run();
   return 0;
}

//========================================================
//{{BenchResults:
/*
cat bench:2017-01-01T07:03:56-06:00.out
rules	method	sample	user	system	elapsed	size_out	
4	0	1	0.31	0.01	0.33	53144
4	0	2	0.24	0.00	0.26	53144
4	0	3	0.23	0.01	0.25	53144
4	1	1	0.26	0.02	0.29	94872
4	1	2	0.27	0.00	0.28	94872
4	1	3	0.26	0.02	0.29	94872
4	2	1	0.25	0.00	0.26	60800
4	2	2	0.25	0.00	0.26	60800
4	2	3	0.24	0.01	0.26	60800
8	0	1	0.28	0.00	0.29	91584
8	0	2	0.27	0.02	0.29	91584
8	0	3	0.28	0.01	0.29	91584
8	1	1	0.54	0.01	0.56	223232
8	1	2	0.54	0.01	0.56	223232
8	1	3	0.54	0.02	0.57	223232
8	2	1	0.31	0.00	0.32	99808
8	2	2	0.30	0.00	0.32	99808
8	2	3	0.29	0.02	0.32	99808
12	0	1	0.54	0.01	0.57	135736
12	0	2	0.54	0.02	0.56	135736
12	0	3	0.53	0.02	0.56	135736
12	1	1	6.76	0.02	6.79	431576
12	1	2	6.75	0.02	6.77	431576
12	1	3	6.73	0.03	6.77	431576
12	2	1	1.04	0.02	1.07	151032
12	2	2	1.06	0.01	1.07	151032
12	2	3	1.03	0.03	1.07	151032

Compilation finished at Sun Jan  1 07:04:28

 */
//}}BenchResults:
//========================================================
