    namespace detail_rule
    {
     //OriginalSource:
     //  [detail_rule]
        // we use this so we can detect if the default parse_rule
        // is the being called.
        struct default_parse_rule_result
        {
            default_parse_rule_result(bool r=false)
              : r(r) {}
            operator bool() const { return r; }
            bool r;
        };
    }//detail_rule namespace
    
    /*! \brief Default parse_rule implementation.
     *  parse_rule's specialized for a particular
     *  rule<ID> are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      , typename Iterator
      , typename Context
      >
    inline detail_rule::default_parse_rule_result
    parse_rule(
        rule_b<ID> rule_
      , Iterator& first
      , Iterator const& last
      , Context const& ctx
      )
    ;
#ifdef USE_TRACING
  #define PARSE_RULE_SPECIALIZED_TRACE_INOUT trace_scope ts(std::string(__func__)+".specialized_yes");
  #define PARSE_RULE_SPECIALIZED_TRACE_RESULT std::cout<<":result="<<result<<"\n";
#else
  #define PARSE_RULE_SPECIALIZED_TRACE_INOUT
  #define PARSE_RULE_SPECIALIZED_TRACE_RESULT
#endif

/*!
  \def BOOST_SPIRIT_DEFINE_(r, data, rule_name)
    \a r is ignored.
    \a data is ignored.
    \a rule_name is the variable name of a variable
       with type, rule<ID>.
    The macro generates an instance of parse_rule
    specialized on decltype(rule_name) as 1st arg.  The body
    calls BOOST_PP_CAT(rule_name,_def) which, of course,
    must be defined before this macro is executed.
    ***For example, if rule_name is x, then there must be
    declared, x_def, in the scope "surrounding" the call
    to this macro.***
    This macro differs from that in [rule] because
    it does *not* call rule_name::operator=.  The reason
    it does not is because, for this file, only parsing
    and no attributes are needed.  The actual
    BOOST_SPIRIT_DEFINE_ calls rule_definitions.
    *Maybe* this is needed for attribute processing, but
    here, there are no attributes.
*/
#define BOOST_SPIRIT_DEFINE_(r, data, rule_name)                                \
    template <typename Iterator, typename Context>                              \
    inline bool parse_rule(                                                     \
        decltype(rule_name)                                                     \
      , Iterator& first, Iterator const& last                                   \
      , Context const& context)                                                 \
    {                                                                           \
        PARSE_RULE_SPECIALIZED_TRACE_INOUT                                      \
        auto const&def=BOOST_PP_CAT(rule_name, _def);                           \
        bool result=def.parse( first, last, context);                           \
        PARSE_RULE_SPECIALIZED_TRACE_RESULT                                     \
        return result;                                                          \
    }                                                                           \
    /***/
#define BOOST_SPIRIT_DEFINE(...) BOOST_PP_SEQ_FOR_EACH(                         \
    BOOST_SPIRIT_DEFINE_, _, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))             \
    /***/
///////////////////////////////////////////////////////////////////////////////
/**
 * \defgroup link_rule_to_rhs_by_context-list.
 * @{
 */
//Purpose:
//  This code stores the rule definition in the
//  parser context argument incrementally.
//  It does this somewhat like the current spirit(2016-07-28) does., AFAICT.
//CopiedModifiedFrom:
//  [toy] and [context].  The [toy] part was modified to
//  prevention duplication of context entries as done
//  by [context].
// 
    template <typename ID, typename T, typename NextContext>
    struct context
    {
        context(T const& val, NextContext const& next_ctx)
            : val(val), next_ctx(next_ctx) {}

        T const& get(mpl::identity<ID>) const
        {
            return val;
        }

        template <typename Identity>
        decltype(std::declval<NextContext>().get(Identity()))
        get(Identity id) const
        {
            return next_ctx.get(id);
        }

        T const& val;
        NextContext const& next_ctx;
    };

    struct empty_context
    {
        template <typename ID>
        detail_rule::rule_undefined get(ID) const
        {
            return detail_rule::rule_undefined();
        }
    };
    
    #ifdef REPORT_CONTEXT_SIZE
            template <typename ID, typename T, typename NextContext>
        std::size_t 
      context_size(context<ID,T,NextContext>const& ctx)
        { return 1+context_size(ctx.next_ctx);
        }
    #endif
    
    /**
     * \defgroup context
     * @{
     */
    //The following code was just copy&pasted from [context]
    //with slight adaptaiion to the above context definitions.
    template <typename Tag, typename Context>
    inline decltype(auto) get(Context const& context)
    {
        return context.get(mpl::identity<Tag>());
    }
    
    /*! \brief Default parse_rule implementation.
     *  parse_rule's specialized for a particular
     *  rule_b<ID> are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      , typename Iterator
      , typename Context
      >
    inline detail_rule::default_parse_rule_result
    parse_rule(
        rule_b<ID> rule_
      , Iterator& first
      , Iterator const& last
      , Context const& ctx
      )
    {
    #ifdef USE_TRACING
      trace_scope ts(std::string(__func__)+".specialized_not");
    #endif
      auto const&parser=get<ID>(ctx);
      constexpr bool is_undefined
        =is_same<decltype(get<ID>(ctx)), detail_rule::rule_undefined>::value;
    #if 1
      static_assert
        ( !is_undefined
        , "BOOST_SPIRIT_DEFINE undefined for this rule."
        );
    #endif
      bool result=parser.parse(first, last, ctx);
    #ifdef USE_TRACING
      std::cout<<":result="<<result<<"\n";
    #endif
      return {result};
    }
    
    namespace detail_make_unique
    {
        template <typename ID, typename T, typename Next, typename FoundVal>
        inline Next const&
        make_unique_context(T& val, Next const& next, FoundVal&)
        {
            return next;
        }
        
        template <typename ID, typename T, typename Next>
        inline context<ID, T, Next>
        make_unique_context(T& val, Next const& next, detail_rule::rule_undefined)
        {
            return { val, next };
        }
    }
    
    template <typename ID, typename T, typename Next>
    inline auto
    make_unique_context(T& val, Next const& next)
    {
        return detail_make_unique::make_unique_context<ID>(val, next, get<ID>(next));
    }    
    /** @}*/ //defgroup context
  
    namespace detail_rule
    {
     //OriginalSource:
     //  [detail_rule].make_rule_context
        template <typename RhsInContext, typename OrigContext>
        auto const&
        make_rule_context
        ( mpl::true_ //is_default_parse_rule
        , RhsInContext const& rhs_in_context //==make_unique_context<ID>(rhs, orig_context);
        , OrigContext  const& orig_context
        )
        {
            return rhs_in_context
              //BOOST_SPIRIT_DEFINE has *not* been done for the rule;
              //hence, inject the rule ID->rhs into context.
              ;
        }
        template <typename RhsInContext, typename OrigContext>
        auto const&
        make_rule_context
        ( mpl::false_ //is_default_parse_rule
        , RhsInContext const& rhs_in_context
        , OrigContext  const& orig_context
        )
        {
            return orig_context
              //BOOST_SPIRIT_DEFINE has been done for the rule;
              //hence, no need to inject the ruled ID->rhs into context.
              ;
        }
    
     //OriginalSource:
     //  [detail_rule].rule_parser::parse_rhs_main
        template <typename ID, typename RHS, typename Iterator, typename Context
          >
        bool parse_rhs_main(
            RHS const& rhs
          , Iterator& first, Iterator const& last
          , Context const& context
          )
        {
            #ifdef USE_TRACING
              trace_scope ts(std::string(__func__));
            #endif
            // see if the user has a BOOST_SPIRIT_DEFINE for this rule
            auto rhs_in_context=make_unique_context<ID>(rhs, context);
            typedef
                decltype(parse_rule(
                    rule_b<ID>(), first, last
                  , rhs_in_context))
            parse_rule_result;

            // If there is no BOOST_SPIRIT_DEFINE for this rule,
            // we'll make a context for this rule tagged by its ID
            // so we can extract the rule later on in the default
            // (generic) parse_rule function.
            typedef
                is_same<parse_rule_result, default_parse_rule_result>
            is_default_parse_rule;

            Iterator i = first;
            bool r = rhs.parse(
                i
              , last
              , make_rule_context(is_default_parse_rule{},rhs_in_context,context)
            );

            if (r)
                first = i;
            return r;
        }
    }//detail_rule namespace
    
/** @}*/ //defgroup link_rule_to_rhs_by_context-list.
