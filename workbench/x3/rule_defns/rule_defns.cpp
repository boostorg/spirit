//OriginalSource:
//  [spirit]
//    https://github.com/boostorg/spirit/tree/develop
//  [toy]
//    [spirit]/workbench/x3/toy/toy.cpp
//  [calc1]
//    [spirit]/example/x3/calc/calc1.cpp  
//  [rule]
//    [spirit]/include/boost/spirit/home/x3/nonterminal/rule.hpp
//  [detail_rule]
//    [spirit]/include/boost/spirit/home/x3/nonterminal/detail/rule.hpp
//  [context]
//    [spirit]/include/boost/spirit/home/x3/support/context.hpp
//  [star]
//    [spirit]/include/boost/spirit/home/x3/operator/kleene.hpp
//Purpose:
//  *  Understand how rule recursion is implemented in [toy] and [rule]
//     and how they differ.
//  *  [toy] uses context to links 1 rule to it's rule_definition; however, there
//     seems to be no easy way to link multiple rule's to their rule_defintion's.
//     Another purpose is finding a relatively easy way to do this.
//Modifications:
//  *  Added rule_defns template class and make_defns function
//     to easily link multiple rule's with their rule_definition's.
//     rule_defns is passed as the Context argument to parse function.
//     The "unspecialized" parse_rule function looks up the rule_definition
//     in it's Context argument (as was done in original spirit code).
//  *  Replaced [toy] context with rule_defns.
//  *  Use macro, USE_MIXED_DEF, to demonstrate combination of
//     BOOST_SPIRIT_DEFINE and rule_defns to link
//     rule to rule_definition.
//  *  Added many debug prints to help illustrate the
//     implementation.
//Conclusion:
//  Use of rule_defns to implement the recursion seems to work fine; however, 
//  it's probably more compiler intensive than
//  use of BOOST_SPIRIT_DEFINE because the rule_defns template
//  is variadic and can be a huge template; whereas, just using
//  rule_definitions would be much smaller templates.
//  OTOH, use of rule_defns is most probably no more compiler intensive than
//  the method used in [toy] because the rule_defns variadic template
//  class does essentially what the context class in [toy] does, except it's
//  easier to put mutiple rule_definitions in it with the make_defns function.
//
//  Maybe a benchmark run could be made to measure the compile-time
//  difference between the 2 implementaions( the one where defined(USE_SPIRIT_DEFINE)
//  and the one where !defined(USE_SPIRIT_DEFINE) ).
//===============
#include "operators.hpp"

#include <boost/core/demangle.hpp>
#include <typeinfo>
  template
  < typename Type
  >
  std::string
type_name()
  {
    return boost::core::demangle(typeid(Type).name());
  }  
#include <utility>
#include <cstring>
#include <boost/type_traits/is_same.hpp>
#include <boost/spirit/home/x3/support/unused.hpp>
#include <boost/preprocessor/variadic/to_seq.hpp>
#include <boost/preprocessor/variadic/elem.hpp>
#include <boost/preprocessor/seq/for_each.hpp>
      template 
      < typename ID
      , typename RHS
      >
    struct rule_definition
      ;
    template <typename ID>
    struct rule
      ;
    
//#define USE_DEFNS
    namespace detail_rule
    {//OriginalSource:
     //  [detail_rule]
      #ifndef USE_DEFNS
        // we use this so we can detect if the default parse_rule
        // is the being called.
        struct default_parse_rule_result
        {
            default_parse_rule_result(bool r)
              : r(r) {}
            operator bool() const { return r; }
            bool r;
        };
      #else
        using default_parse_rule_result = bool;
      #endif
    }
    
    /*! \brief Default parse_rule implementation.
     *  parse_rule's specialized for a particular
     *  rule<ID> are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      , typename Iterator
      , typename Context
      >
    inline detail_rule::default_parse_rule_result
    parse_rule(
        rule<ID> rule_
      , Iterator& first
      , Iterator const& last
      , Context const& ctx
      )
    ;
    struct rule_undefined
      /**@brief
       *  Tag value indicating a rule has not been defined.
       */
      {
          template <typename Iterator, typename Context>
          bool parse(Iterator& first, Iterator last, Context const& ctx) const
          /*! \brief 
           *    Prevent redundant compiletime error in default parse_rule
           *    when static_assert fires.
           */
          {
              assert(false);
              return false;
          }
      };
#ifdef USE_DEFNS
///////////////////////////////////////////////////////////////////////////////
/**
 * \defgroup link_rule_to_rhs_by_multi-inheritance
 * @{
 */
//Purpose:
//  This code uses multi-inheritance to record the link between
//  a rule<ID> and it's rule_definition.
//  It's not in current spirit (2016-07-28), AFAICT.

      template
      < typename... RuleDefinition
      >
      struct
    rule_defns
      ;
      template
      < typename... ID
      , typename... RHS
      >
    struct rule_defns
      < rule_definition
        < ID
        , RHS
        >...
      >
      : rule_definition
        < ID
        , RHS
        >...
      {
      private:
          template
          < typename GetId
          >
            static
          auto constexpr
        get_def_impl
          ( ... //overload resolution prefers anything over ...
          )
          /**@brief
           *  No rule_definition< GetId, RHS> in superclasses.
           */
          {
              return rule_undefined();
          }
          template
          < typename GetID
          , typename GetRHS
          >
            static
          auto constexpr
        get_def_impl
          ( rule_definition
            < GetID
            , GetRHS
            >const* a_def
          )
          /**@brief
           *  Only used by member function, get_def()const.
           */
          {
              return *a_def;
          }
      public:
          template
          < typename GetID
          >
          auto  constexpr
        get_def()const
          /**@brief
           *  retrieve the definition of AnVarble.
           */
          {
            return get_def_impl<GetID>(this);
          }
        template<typename... Defs>
        rule_defns(Defs... defs)
          : rule_definition
            < ID
            , RHS
            >(defs)...
          {}
        
      };//rule_defns
      template
      < typename ID
      , typename... RuleDefinition
      >
      auto
    get
      ( rule_defns<RuleDefinition...>const& defs
      )
      {
        return defs.template get_def<ID>();
      }
    using empty_context=rule_defns<>;
      template
      < typename... ID
      , typename... RHS
      >
      auto
    make_defs
      ( rule_definition< ID, RHS>... defs
      )
      {
          return 
            rule_defns
            < rule_definition< ID, RHS>...
            >(defs...);
      }
    
/** @}*/
#else
///////////////////////////////////////////////////////////////////////////////
/**
 * \defgroup link_rule_to_rhs_by_context-list.
 * @{
 */
//Purpose:
//  This code stores the rule definition in the
//  parser context argument incrementally.
//  It does this somewhat like the current spirit(2016-07-28) does., AFAICT.
//CopiedModifiedFrom:
//  [toy] and [context].  The [toy] part was modified to
//  prevention duplication of context entries as done
//  by [context].
// 
    template <typename ID, typename T, typename NextContext>
    struct context
    {
        context(T const& val, NextContext const& next_ctx)
            : val(val), next_ctx(next_ctx) {}

        T const& get(mpl::identity<ID>) const
        {
            return val;
        }

        template <typename Identity>
        decltype(std::declval<NextContext>().get(Identity()))
        get(Identity id) const
        {
            return next_ctx.get(id);
        }

        T const& val;
        NextContext const& next_ctx;
    };

    struct empty_context
    {
        template <typename ID>
        rule_undefined get(ID) const
        {
            return rule_undefined();
        }
    };
    
    /**
     * \defgroup context
     * @{
     */
    //The following code was just copy&pasted from [context]
    //with slight adaptaiion to the above context definitions.
    template <typename Tag, typename Context>
    inline decltype(auto) get(Context const& context)
    {
        return context.get(mpl::identity<Tag>());
    }
    
    namespace detail_make_unique
    {
        template <typename ID, typename T, typename Next, typename FoundVal>
        inline Next const&
        make_unique_context(T& val, Next const& next, FoundVal&)
        {
            return next;
        }
        
        template <typename ID, typename T, typename Next>
        inline context<ID, T, Next>
        make_unique_context(T& val, Next const& next, rule_undefined)
        {
            return { val, next };
        }
    }
    
    template <typename ID, typename T, typename Next>
    inline auto
    make_unique_context(T& val, Next const& next)
    {
        return detail_make_unique::make_unique_context<ID>(val, next, get<ID>(next));
    }    
    /** @}*/ //defgroup context
  
    namespace detail_rule
    {//OriginalSource:
     //  [detail_rule].rule_parser::parse_rhs_main
        template <typename ID, typename RHS, typename Context>
        Context const&
        make_rule_context(RHS const& rhs, Context const& context
          , mpl::false_ /* is_default_parse_rule */)
        {
            return context;
        }
    
        template <typename ID, typename RHS, typename Context>
        auto make_rule_context(RHS const& rhs, Context const& context
          , mpl::true_ /* is_default_parse_rule */ )
        {
            return make_unique_context<ID>(rhs, context);
        }
        
        template <typename ID, typename RHS, typename Iterator, typename Context
          >
        bool parse_rhs_main(
            RHS const& rhs
          , Iterator& first, Iterator const& last
          , Context const& context
          )
        {
            #ifdef USE_TRACING
              trace_scope ts(std::string(__func__));
            #endif
            // see if the user has a BOOST_SPIRIT_DEFINE for this rule
            typedef
                decltype(parse_rule(
                    rule<ID>(), first, last
                  , make_unique_context<ID>(rhs, context)))
            parse_rule_result;

            // If there is no BOOST_SPIRIT_DEFINE for this rule,
            // we'll make a context for this rule tagged by its ID
            // so we can extract the rule later on in the default
            // (generic) parse_rule function.
            typedef
                is_same<parse_rule_result, default_parse_rule_result>
            is_default_parse_rule;

            Iterator i = first;
            bool r = rhs.parse(
                i
              , last
              , make_rule_context<ID>(rhs, context, is_default_parse_rule())
            );

            if (r)
                first = i;
            return r;
        }
    }//detail_rule namespace
    
/** @}*/ //defgroup link_rule_to_rhs_by_context-list.
#endif//USE_DEFNS

    /*! \brief Default parse_rule implementation.
     *  parse_rule's specialized for a particular
     *  rule<ID> are generated by using the 
     *  BOOST_SPIRIT_DEFINE macro, which is
     *  defined below.
     */
      template 
      < typename ID
      , typename Iterator
      , typename Context
      >
    inline detail_rule::default_parse_rule_result
    parse_rule(
        rule<ID> rule_
      , Iterator& first
      , Iterator const& last
      , Context const& ctx
      )
    {
    #ifdef USE_TRACING
      trace_scope ts(std::string(__func__)+".specialized_not");
    #endif
      auto const&parser=get<ID>(ctx);
      constexpr bool is_undefined
        =is_same<decltype(get<ID>(ctx)), rule_undefined>::value;
    #if 1
      static_assert
        ( !is_undefined
        , "BOOST_SPIRIT_DEFINE undefined for this rule."
        );
    #endif
      bool result=parser.parse(first, last, ctx);
    #ifdef USE_TRACING
      std::cout<<":result="<<result<<"\n";
    #endif
      return result;
    }
    
      template 
      < typename ID
      , typename RHS
      >
    struct rule_definition 
      : parser
        < rule_definition
          < ID
          , RHS
          >
        >
    {
        rule_definition(RHS const& rhs)
          : rhs(rhs){}
        
          template <typename Iterator, typename Context>
          bool 
        parse
          ( Iterator& first
          , Iterator last
          , Context const& ctx
          ) const
        {
        #ifdef USE_TRACING
	  std::ostringstream os;
	  os<<*this;
	  os<<"::parse";
	  std::string str=os.str();
	  trace_scope ts(str);
        #endif
        #ifndef USE_DEFNS
          bool result=detail_rule::parse_rhs_main<ID>
            ( rhs, first, last, ctx);
        #else
          bool result=rhs.parse( first, last, ctx);
        #endif
          return result;
        }
        
        RHS rhs;

        friend std::ostream&
	operator<<(std::ostream& os, rule_definition<ID,RHS>const&p)
        {
	    os<<"rule_definition<"<<type_name<ID>()<<">";
	    return os;
        }
    };

    template <typename ID>
    struct rule : parser<rule<ID>>
    {
        rule(){}
        
        template <typename Derived>
        rule_definition<ID, Derived>
        operator=(parser<Derived> const& definition) const
        {
            return rule_definition<ID, Derived>(definition.derived());
        }

        template <typename Iterator, typename Context>
        bool parse(Iterator& first, Iterator last, Context const& ctx) const
        {
        #ifdef USE_TRACING
	  std::ostringstream os;
	  os<<type_name<rule<ID> >();
	  os<<"::parse";
	  std::string str=os.str();
	  trace_scope ts(str);
        #endif
          bool result=parse_rule(*this, first, last, ctx);
        #ifdef USE_TRACING
	  std::cout<<":result="<<result<<"\n";
        #endif
	  return result;
        }
        
        friend std::ostream&
	operator<<(std::ostream& os, rule<ID>const&p)
        {
          os<<type_name<ID>();
          return os;
        }
    };
    
#ifdef USE_TRACING
  #define PARSE_RULE_SPECIALIZED_TRACE_INOUT trace_scope ts(std::string(__func__)+".specialized_yes");
  #define PARSE_RULE_SPECIALIZED_TRACE_RESULT std::cout<<":result="<<result<<"\n";
#else
  #define PARSE_RULE_SPECIALIZED_TRACE_INOUT
  #define PARSE_RULE_SPECIALIZED_TRACE_RESULT
#endif
/*!
  \def BOOST_SPIRIT_DEFINE_(r, data, rule_name)
    \a r is ignored.
    \a data is ignored.
    \a rule_name is the variable name of a variable
       with type, rule<ID>.
    The macro generates an instance of parse_rule
    specialized on decltype(rule_name) as 1st arg.  The body
    calls BOOST_PP_CAT(rule_name,_def) which, of course,
    must be defined before this macro is executed.
    ***For example, if rule_name is x, then there must be
    declared, x_def, in the scope "surrounding" the call
    to this macro.***
    This macro differs from that in [rule] because
    it does *not* call rule_name::operator=.  The reason
    it does not is because, for this file, only parsing
    and no attributes are needed.  The actual
    BOOST_SPIRIT_DEFINE_ calls rule_definitions.
    *Maybe* this is needed for attribute processing, but
    here, there are no attributes.
*/
#define BOOST_SPIRIT_DEFINE_(r, data, rule_name)                                \
    template <typename Iterator, typename Context>                              \
    inline bool parse_rule(                                                     \
        decltype(rule_name)                                                     \
      , Iterator& first, Iterator const& last                                   \
      , Context const& context)                                                 \
    {                                                                           \
        PARSE_RULE_SPECIALIZED_TRACE_INOUT                                      \
        auto const&def=BOOST_PP_CAT(rule_name, _def);                           \
        bool result=def.parse( first, last, context);                           \
        PARSE_RULE_SPECIALIZED_TRACE_RESULT                                     \
        return result;                                                          \
    }                                                                           \
    /***/
#define BOOST_SPIRIT_DEFINE(...) BOOST_PP_SEQ_FOR_EACH(                         \
    BOOST_SPIRIT_DEFINE_, _, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))             \
    /***/
///////////////////////////////////////////////////////////////////////////////
// test code

template <typename Iterator, typename Derived, typename Context=empty_context>
inline bool parse(parser<Derived> const& p, Iterator& first, Iterator last, Context ctx=Context())
{
   return p.derived().parse(first, last, ctx);
}

template <typename Parser, typename Context=empty_context>
void test_parse(Parser const& p, char const* in, Context ctx=Context())
{
    std::cout<<__func__<<":in.beg="<<in<<"\n";
    char const*const end=in + std::strlen(in);
    auto result=parse(p, in, end, ctx);
    while(result && in != end) result=parse(p, in, end, ctx);
    std::cout<<__func__<<":in.end="<<in<<"\n";
    std::cout<<__func__<<":result="<<result<<"\n";
}

#define USE_SPIRIT_DEFINE
  /**@brief
   *  When above is defined, use "mostly" BOOST_SPIRIT_DEFINE
   *  to link rule's with their rule_definition's.
   */
//#define USE_MIXED_DEF
  /**@brief
   *  When above is defined, use a combination of
   *  BOOST_SPIRIT_DEFINE and rule_defns in
   *  some grammar.
   */
//#define USE_MISSING_DEF
  /**@brief
   *  When defined(USE_MISSING_DEF) && !defined(USE_MIXED_DEF)
   *  should cause compile time error
   *  because some rule_definition is missing.
   *  Of course this depends on code below actually
   *  miss a rule_definition when the above is defined.
   */
namespace simple_gram
{
//#define SIMPLE_GRAM
#if defined(SIMPLE_GRAM)
  class x_rul{};
  rule<x_rul> const x;
  auto const x_def = (x=char_('x') | char_('a') >> x);
  
  #ifdef USE_SPIRIT_DEFINE
    BOOST_SPIRIT_DEFINE(
        x
    );
    auto const ctx = empty_context();
  #elif defined(USE_DEFNS)
    auto const ctx = 
      make_defs
      ( x_def
      );
  #else
    auto const ctx = empty_context();
  #endif //USE_SPIRIT_DEFINE
    void run()
    {
      trace_scope ts("simple_gram");
      //test_parse(x, "x", ctx) ;
      //test_parse(x, "ax", ctx) ;
      test_parse(x_def, "aaaaax", ctx) ;
      //test_parse(x, "aaz", ctx) ;
      std::cout << "==========================================" << std::endl;
    }
#else
    void run(){}  
#endif //SIMPLE_GRAM
}//exit simple_gram namespace
namespace calc_gram_recur
{
#define CALC_GRAM_RECUR
#if defined(CALC_GRAM_RECUR)
//The following is pretty much copied from [calc1]:
    class expr_rul{};
    rule<expr_rul> const expr;
    class fact_rul{};
    rule<fact_rul> const fact;
    class term_rul{};
    rule<term_rul> const term;

  #ifdef USE_SPIRIT_DEFINE
    auto const expr_def =
        term
        >> *( char_('+') >> term
            )
        ;

    auto const term_def =
        fact
        >> *( char_('*') >> fact
            )
        ;

    auto const fact_def =
            char_('0')
        |   char_('1')
        |   char_('2')
        |   char_('3')
        |   char_('(') >> expr >> char_(')')
        //For simplicity, no unary + operator.
        ; 
   
    #ifndef USE_MISSING_DEF
      BOOST_SPIRIT_DEFINE(
          expr
        , term
        , fact
      );
    #else
      BOOST_SPIRIT_DEFINE(
          expr
        , fact
      );
    #endif
    #ifdef USE_MIXED_DEF
      auto const ctx = 
        make_defs
        ( 
        term =
          fact
          >> *( char_('*') >> fact
              )
        );
    #else
      auto const ctx = empty_context();
    #endif
  #else
    auto const ctx = 
      make_defs
      ( 
      expr =
        term
        >> *( char_('+') >> term
            )
        ,
    #ifndef USE_MISSING_DEF
      term =
        fact
        >> *( char_('*') >> fact
            )
        ,
    #endif
      fact =
            char_('0')
        |   char_('1')
        |   char_('2')
        |   char_('3')
        |   char_('(') >> expr >> char_(')')
        //For simplicity, no unary + operator.
      );
  #endif
  void run()
  {
    using namespace calc_gram_recur;
    trace_scope ts("calc_gram_recur");
//    test_parse(expr_def, "1", ctx) ;
//    test_parse(expr_def, "1+2", ctx) ;
//    test_parse(expr_def, "1+2+3*3*2*1", ctx) ;
    test_parse(expr, "1*(2+3)*2", ctx) ;
//    test_parse(expr_def, "1+2/3", ctx) ;
    std::cout << "==========================================" << std::endl;
  }
#else
    void run(){}  
#endif //CALC_GRAM_RECUR
}//exit calc_gram_recur namespace
namespace calc_gram_tree
{
#define CALC_GRAM_TREE
#if defined(CALC_GRAM_TREE) && !defined(USE_DEFNS)
//The following is pretty much copied from [calc1]:
    class expr_rul{};
    rule<expr_rul> const expr;
    class fact_rul{};
    rule<fact_rul> const fact;
    class term_rul{};
    rule<term_rul> const term;

    auto const fact_def = fact =
            char_('0')
        |   char_('1')
        |   char_('2')
        |   char_('3')
        //|   char_('(') >> expr >> char_(')')
        //Cannot have recursion without BOOST_SPIRIT_DEFINE :(
        ; 
   
    auto const term_def = term =
        fact_def
        >> *( char_('*') >> fact_def
            )
        ;

    auto const expr_def = expr =
        term_def
        >> *( char_('+') >> term_def
            )
        ;

    auto const ctx = empty_context();
  void run()
  {
    using namespace calc_gram_tree;
    trace_scope ts("calc_gram_tree");
//    test_parse(expr_def, "1", ctx) ;
//    test_parse(expr_def, "1+2", ctx) ;
    test_parse(expr_def, "1+2+3*3*2*1", ctx) ;
    std::cout << "==========================================" << std::endl;
  }
#else
    void run(){}  
#endif //CALC_GRAM_TREE
}//exit calc_gram_tree namespace
int main()
{

    iostreams::indent_scoped_ostreambuf<char>
  indent_outbuf(std::cout,2);
  #ifdef USE_IOSTREAMS_UTILITY
  std::cout<<"yes defined(USE_IOSTREAMS_UTILITY)\n";
  #else
  std::cout<<"not defined(USE_IOSTREAMS_UTILITY)\n";
  #endif
  #ifdef USE_SPIRIT_DEFINE
  std::cout<<"yes defined(USE_SPIRIT_DEFINE)\n";
  #else
  std::cout<<"not defined(USE_SPIRIT_DEFINE)\n";
  #endif
  #ifdef USE_MIXED_DEF
  std::cout<<"yes defined(USE_MIXED_DEF)\n";
  #else
  std::cout<<"not defined(USE_MIXED_DEF)\n";
  #endif
  #ifdef USE_TRACING
  std::cout<<"yes defined(USE_TRACING)\n";
  #else
  std::cout<<"not defined(USE_TRACING)\n";
  #endif
  #ifdef USE_DEFNS
  std::cout<<"yes defined(USE_DEFNS)\n";
  #else
  std::cout<<"not defined(USE_DEFNS)\n";
  #endif
  simple_gram::run();
  calc_gram_recur::run();
  calc_gram_tree::run();
   return 0;
}

//========================================================
//{{Compile&Output:
/*
 */
//}}Compile&Output:
//========================================================
