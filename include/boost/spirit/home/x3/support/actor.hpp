/*//////////////////////////////////////////////////////////////////////////////
    Copyright (c) 2014 Jamboree

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//////////////////////////////////////////////////////////////////////////////*/
#ifndef BOOST_SPIRIT_X3_ACTOR_HPP_INCLUDED
#define BOOST_SPIRIT_X3_ACTOR_HPP_INCLUDED

#if defined(_MSC_VER)
#pragma once
#endif

#include <tuple>
#include <boost/phoenix/core.hpp>
#include <boost/fusion/include/at.hpp>
#include <boost/fusion/include/single_view.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/variadic/to_seq.hpp>
#include <boost/preprocessor/seq/for_each.hpp>


namespace boost { namespace spirit { namespace x3
{
    struct rule_context_tag;
    struct local_variables_tag;
}}}

namespace boost { namespace spirit { namespace x3 { namespace detail
{
    template <typename Seq>
    inline typename enable_if<fusion::traits::is_sequence<Seq>, Seq&>::type
    as_sequence(Seq& seq)
    {
        return seq;
    }

    template <typename Seq>
    inline typename disable_if<fusion::traits::is_sequence<Seq>,
        fusion::single_view<Seq&>>::type
    as_sequence(Seq& seq)
    {
        return fusion::single_view<Seq&>(seq);
    }
    
    struct full_attr_eval
    {
        template <typename Env>
        auto eval(Env const& env) const->decltype(fusion::at_c<1>(env.args()))
        {
            return fusion::at_c<1>(env.args());
        }
    };
    
    template <int N>
    struct attr_eval
    {
        template <typename Env>
        auto eval(Env const& env) const->
            decltype(fusion::at_c<N>(as_sequence(fusion::at_c<1>(env.args()))))
        {
            return fusion::at_c<N>(as_sequence(fusion::at_c<1>(env.args())));
        }
    };
    
    struct val_eval
    {
        template <typename Env>
        auto eval(Env const& env) const->
            decltype(x3::get<rule_context_tag>(fusion::at_c<0>(env.args())).val())
        {
            return x3::get<rule_context_tag>(fusion::at_c<0>(env.args())).val();
        }
    };
    
    template <int N>
    struct param_eval
    {
        template <typename Env>
        auto eval(Env const& env) const->
            decltype(std::get<N>(x3::get<rule_context_tag>(fusion::at_c<0>(env.args())).params()))
        {
            return std::get<N>(x3::get<rule_context_tag>(fusion::at_c<0>(env.args())).params());
        }
    };

    template <int N>
    struct local_var_eval
    {
        template <typename Env>
        auto eval(Env const& env) const->
            decltype(std::get<N>(x3::get<local_variables_tag>(fusion::at_c<0>(env.args()))))
        {
            return std::get<N>(x3::get<local_variables_tag>(fusion::at_c<0>(env.args())));
        }
    };
}}}}

namespace boost { namespace spirit { namespace x3
{
    template <typename Eval>
    struct actor : Eval
    {
        template <typename Env>
        struct result
        {
            typedef decltype(declval<Eval>().eval(declval<Env>())) type;
        };
    };
    
    template <typename Eval>
    using make_actor = phoenix::actor<actor<Eval>>;
    
    template <int N>
    using attribute_actor = make_actor<detail::attr_eval<N>>; 

    template <int N>
    using parameter_actor = make_actor<detail::param_eval<N>>;
    
    template <int N>
    using local_variable_actor = make_actor<detail::local_var_eval<N>>;
    
    // _0 refers to the whole attribute as generated by the lhs parser
    typedef make_actor<detail::full_attr_eval> _0_type;
    
    // _1, _2, ... refer to the attributes of the single components the lhs
    // parser is composed of
    typedef attribute_actor<0> _1_type;
    typedef attribute_actor<1> _2_type;
    typedef attribute_actor<2> _3_type;
    typedef attribute_actor<3> _4_type;
    typedef attribute_actor<4> _5_type;
    typedef attribute_actor<5> _6_type;
    typedef attribute_actor<6> _7_type;
    typedef attribute_actor<7> _8_type;
    typedef attribute_actor<8> _9_type;
    typedef attribute_actor<9> _10_type;
    
    // _val refers to the 'return' value of a rule (same as _r0)
    typedef make_actor<detail::val_eval> _val_type;
    typedef make_actor<detail::val_eval> _r0_type;
    
    // _r1, _r2, ... refer to the rule arguments
    typedef parameter_actor<0> _r1_type;
    typedef parameter_actor<1> _r2_type;
    typedef parameter_actor<2> _r3_type;
    typedef parameter_actor<3> _r4_type;
    typedef parameter_actor<4> _r5_type;
    typedef parameter_actor<5> _r6_type;
    typedef parameter_actor<6> _r7_type;
    typedef parameter_actor<7> _r8_type;
    typedef parameter_actor<8> _r9_type;
    typedef parameter_actor<9> _r10_type;
        
    // _a, _b, ... refer to the local variables of a rule
    typedef local_variable_actor<0> _a_type;
    typedef local_variable_actor<1> _b_type;
    typedef local_variable_actor<2> _c_type;
    typedef local_variable_actor<3> _d_type;
    typedef local_variable_actor<4> _e_type;
    typedef local_variable_actor<5> _f_type;
    typedef local_variable_actor<6> _g_type;
    typedef local_variable_actor<7> _h_type;
    typedef local_variable_actor<8> _i_type;
    typedef local_variable_actor<9> _j_type;
}}}

BOOST_PHOENIX_DEFINE_CUSTOM_TERMINAL(
    template <typename Eval>
  , boost::spirit::x3::actor<Eval>
  , mpl::false_                 // is not nullary
  , v2_eval(
        proto::make<
            boost::spirit::x3::actor<Eval>()
        >
      , proto::call<
            functional::env(proto::_state)
        >
    )
)

#define SPIRIT_USE_ACTOR(r, data, elem)                                         \
    BOOST_PP_CAT(::boost::spirit::x3::elem, _type) const elem{};

#define BOOST_SPIRIT_USE_ACTORS(...) BOOST_PP_SEQ_FOR_EACH(                     \
    SPIRIT_USE_ACTOR, _, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))
    /***/


#endif

